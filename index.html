<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Drifter</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);
        }
        html, body {
            width: 100%;
            height: 100%;
        }
        body {
            background: #1a1a2e;
            overflow: hidden;
            font-family: Arial, sans-serif;
            min-height: 100dvh;
        }
        #game {
            display: block;
            background: linear-gradient(#16213e, #1a1a2e);
            touch-action: none;
            width: 100vw;
            height: 100vh;
            max-height: 100dvh;
        }
        #ui {
            position: fixed;
            top: calc(15px + var(--safe-top));
            left: calc(15px + var(--safe-left));
            color: #ffd700;
            font-size: 22px;
            font-weight: bold;
            z-index: 10;
            background: rgba(0,0,0,0.35);
            padding: 10px 18px;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-start;
            min-width: 150px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25);
        }
        body.orientation-portrait #ui {
            top: auto;
            bottom: calc(12px + var(--safe-bottom));
            left: 50%;
            right: auto;
            transform: translateX(-50%);
            width: min(520px, calc(100vw - 24px));
            min-width: 0;
            flex-direction: row;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            gap: 6px 12px;
            padding: 10px 14px;
            background: rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(8px);
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
        }
        body.orientation-portrait #ui .score-row,
        body.orientation-portrait #ui #coinTracker,
        body.orientation-portrait #ui #diffDisplay {
            flex: 1 1 calc(50% - 12px);
            justify-content: center;
            text-align: center;
            display: flex;
            align-items: center;
        }
        body.orientation-portrait #ui #diffDisplay {
            font-size: 13px;
            opacity: 0.85;
        }
        body.touch-primary.orientation-portrait #ui {
            bottom: calc(120px + var(--safe-bottom));
        }
        body.orientation-portrait #ui .status-line,
        body.orientation-portrait #ui #shieldStatus,
        body.orientation-portrait #ui #boostStatus {
            flex: 1 1 100%;
            text-align: center;
            font-size: 12px;
        }
        body.orientation-portrait #ui .score-label {
            font-size: 20px;
        }
        @media (max-width: 480px) {
            body.orientation-portrait #ui {
                font-size: 16px;
            }
            body.orientation-portrait #ui .score-row {
                font-size: 18px;
            }
        }
        .score-row {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 20px;
            letter-spacing: 0.5px;
        }
        .score-row .score-label {
            font-size: 22px;
        }
        #coinTracker {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #fff4b3;
            font-size: 18px;
            font-weight: bold;
            position: relative;
        }
        #coinTracker span {
            font-size: 20px;
        }
        .coin-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 25%, #fffbd1, #ffe066 45%, #d9a404 100%);
            border: 2px solid #ffe066;
            box-shadow: 0 0 18px rgba(255, 213, 0, 0.7);
            position: relative;
            transition: transform 0.15s;
        }
        .coin-icon::after {
            content: '';
            position: absolute;
            top: 6px;
            left: 9px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.6);
            opacity: 0.75;
        }
        .coin-icon.pop {
            animation: coin-pop 0.35s ease;
        }
        @keyframes coin-pop {
            0% { transform: scale(1); }
            30% { transform: scale(1.35); }
            60% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }
        #coinGainTag {
            position: absolute;
            right: -10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 16px;
            color: #ffeaa7;
            opacity: 0;
            pointer-events: none;
        }
        #coinGainTag.visible {
            animation: coin-tag 0.7s ease forwards;
        }
        #coinGainTag.loss {
            color: #ff6b6b;
        }
        @keyframes coin-tag {
            0% { opacity: 0; transform: translate(12px, -10px); }
            20% { opacity: 1; transform: translate(0, -22px); }
            100% { opacity: 0; transform: translate(-8px, -40px); }
        }
        #shieldStatus {
            font-size: 14px;
            color: #4ecdc4;
            min-height: 18px;
            letter-spacing: 0.5px;
        }
        #boostStatus {
            font-size: 14px;
            color: #74b9ff;
            min-height: 18px;
            letter-spacing: 0.5px;
        }
        .status-line {
            font-size: 13px;
            color: #9fd9ff;
            min-height: 17px;
            letter-spacing: 0.4px;
        }
        .status-line.alert { color: #ffb347; }
        .status-line.success { color: #4ecdc4; }
        #hangarPanel {
            width: 100%;
            max-width: 760px;
            margin: 10px auto 30px;
            background: rgba(10, 15, 30, 0.7);
            border: 1px solid rgba(78, 205, 196, 0.2);
            border-radius: 16px;
            padding: 20px 24px;
            box-shadow: 0 10px 28px rgba(0, 0, 0, 0.35);
        }
        .hangar-header {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .hangar-header h2 {
            color: #4ecdc4;
            font-size: 26px;
            margin: 0;
        }
        #bankDisplay {
            color: #ffeaa7;
            font-size: 20px;
            font-weight: bold;
            letter-spacing: 0.04em;
        }
        .hangar-note {
            color: #9baed1;
            font-size: 14px;
            margin-bottom: 14px;
            text-align: left;
        }
        #upgradeGrid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 15px;
            width: 100%;
        }
        .upgrade-card {
            background: rgba(20, 28, 50, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 14px;
            padding: 14px 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: relative;
            overflow: hidden;
        }
        .upgrade-card::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 14px;
            border: 1px solid rgba(78, 205, 196, 0.18);
            pointer-events: none;
        }
        .upgrade-card.maxed::after {
            border-color: rgba(255, 215, 0, 0.35);
        }
        .upgrade-title {
            color: #ffffff;
            font-size: 18px;
            font-weight: bold;
        }
        .upgrade-level {
            color: #a8dadc;
            font-size: 14px;
        }
        .upgrade-desc {
            color: #ced6f0;
            font-size: 14px;
            flex: 1;
        }
        .upgrade-card button {
            margin-top: 4px;
            padding: 10px 18px;
            border-radius: 999px;
            border: none;
            background: linear-gradient(120deg, #4ecdc4, #1dd1a1);
            color: #051019;
            font-weight: bold;
            cursor: pointer;
            transition: opacity 0.2s, transform 0.2s;
        }
        .upgrade-card button:disabled {
            background: rgba(255, 255, 255, 0.15);
            color: #d7d7d7;
            cursor: not-allowed;
        }
        .upgrade-card button:not(:disabled):hover {
            opacity: 0.85;
            transform: translateY(-2px);
        }
        
        @media (max-width: 600px) {
            #ui {
                font-size: 18px;
                padding: 8px 13px;
            }
            #coinTracker span {
                font-size: 18px;
            }
        }
        #menu {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: calc(40px + var(--safe-top)) calc(24px + var(--safe-right)) calc(30px + var(--safe-bottom)) calc(24px + var(--safe-left));
            z-index: 20;
            overflow-y: auto;
            box-sizing: border-box;
        }
        #menu.hidden { display: none; }
        #menu h1 {
            color: #4ecdc4;
            font-size: 48px;
            margin-bottom: 20px;
        }
        #menu p {
            color: #aaa;
            margin-bottom: 20px;
            padding: 0 10px;
        }
        #menu button {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 30px;
            cursor: pointer;
        }
        #menu button:hover { background: #ff5252; }
        
        /* Mobile responsive */
        @media (max-width: 600px) {
            #menu {
                padding: calc(20px + var(--safe-top)) calc(14px + var(--safe-right)) calc(20px + var(--safe-bottom)) calc(14px + var(--safe-left));
            }
            #menu h1 {
                font-size: 32px;
            }
            #menu p {
                font-size: 14px;
            }
            #difficulties {
                flex-direction: column;
                gap: 8px;
            }
            .diff-btn {
                padding: 12px 30px;
                font-size: 16px;
                width: 80%;
            }
            #skins {
                max-width: 90vw;
                gap: 10px;
            }
            .skin-btn {
                width: 55px;
                height: 40px;
            }
            #menu button {
                padding: 12px 30px;
                font-size: 18px;
            }
        }
        #finalScore {
            color: #ffd700;
            font-size: 64px;
            margin: 20px 0;
        }
        .version-pill {
            margin-top: 5px;
            margin-bottom: 25px;
            padding: 6px 18px;
            border-radius: 999px;
            border: 1px solid rgba(168, 218, 220, 0.35);
            color: #a8dadc;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            font-size: 13px;
            background: rgba(26, 26, 46, 0.6);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        #difficultySelector {
            margin: 15px 0;
            width: 100%;
            text-align: center;
        }
        #difficulties {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            padding: 0 10px;
        }
        .diff-btn {
            padding: 10px 25px;
            border: 2px solid #444;
            border-radius: 20px;
            background: transparent;
            color: #aaa;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            min-width: 100px;
        }
        .diff-btn:hover {
            border-color: #888;
            color: #fff;
        }
        .diff-btn.selected {
            border-color: #4ecdc4;
            color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
            box-shadow: 0 8px 22px rgba(78, 205, 196, 0.35);
            transform: translateY(-2px) scale(1.02);
        }
        .diff-btn.selected::after {
            content: 'Active';
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #ffd700;
        }
        .diff-btn.easy.selected { border-color: #2ecc71; color: #2ecc71; background: rgba(46, 204, 113, 0.1); }
        .diff-btn.medium.selected { border-color: #f39c12; color: #f39c12; background: rgba(243, 156, 18, 0.1); }
        .diff-btn.hard.selected { border-color: #e74c3c; color: #e74c3c; background: rgba(231, 76, 60, 0.1); }
        .diff-btn.impossible.selected { border-color: #c0392b; color: #c0392b; background: rgba(192, 57, 43, 0.1); }
        #difficultyIndicator {
            margin-top: 24px;
            color: #ffd27f;
            font-size: 14px;
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }
        #difficultyIndicator strong {
            letter-spacing: normal;
            font-size: 18px;
            color: #ffffff;
        }
        #difficultyIndicator[data-difficulty="easy"] strong { color: #2ecc71; }
        #difficultyIndicator[data-difficulty="medium"] strong { color: #f39c12; }
        #difficultyIndicator[data-difficulty="hard"] strong { color: #e74c3c; }
        #difficultyIndicator[data-difficulty="impossible"] strong { color: #c0392b; }
        #skinSelector {
            margin: 15px 0;
            width: 100%;
            text-align: center;
        }
        #skins {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            padding: 0 10px;
            max-width: 400px;
            margin: 0 auto;
        }
        #startBtn {
            margin: 25px auto 35px;
        }
        .skin-btn {
            width: 70px;
            height: 50px;
            border: 3px solid #444;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        .skin-btn:hover {
            transform: scale(1.1);
            border-color: #888;
        }
        .skin-btn.selected {
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }
        .skin-btn canvas {
            width: 100%;
            height: 100%;
        }

        #orientationHint {
            position: fixed;
            top: calc(16px + var(--safe-top));
            right: calc(16px + var(--safe-right));
            background: rgba(0, 0, 0, 0.55);
            color: #ffeaa7;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 999px;
            padding: 8px 14px;
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            z-index: 12;
            opacity: 0;
            transform: translateY(-6px);
            transition: opacity 0.25s ease, transform 0.25s ease;
            pointer-events: none;
            display: none;
        }
        body.touch-primary #orientationHint {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        #orientationHint.visible {
            opacity: 1;
            transform: translateY(0);
        }
        #mobileControls {
            position: fixed;
            bottom: calc(16px + var(--safe-bottom));
            left: 50%;
            transform: translateX(-50%);
            width: min(520px, calc(100vw - 24px));
            background: rgba(5, 10, 25, 0.78);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 18px;
            padding: 12px 16px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.45);
            display: none;
            flex-direction: column;
            gap: 10px;
            align-items: stretch;
            z-index: 11;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }
        body.touch-primary #mobileControls {
            display: flex;
        }
        #mobileControls.active {
            opacity: 1;
            pointer-events: auto;
        }
        #boostButton {
            appearance: none;
            border: none;
            border-radius: 14px;
            padding: 12px 18px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(135deg, #ff6b6b, #ffa36c);
            color: #fff;
            letter-spacing: 0.03em;
            box-shadow: 0 8px 22px rgba(0, 0, 0, 0.35);
            cursor: pointer;
            transition: transform 0.15s ease, opacity 0.15s ease;
        }
        #boostButton:disabled {
            opacity: 0.55;
            cursor: not-allowed;
        }
        #boostButton:active {
            transform: translateY(1px);
        }
        .mobile-hint {
            text-align: center;
            font-size: 13px;
            color: #b8d0ff;
            letter-spacing: 0.04em;
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <div id="ui">
        <div class="score-row">
            <span class="score-label">â˜…</span>
            <span id="score">0</span>
        </div>
        <div id="coinTracker">
            <div id="coinIcon" class="coin-icon"></div>
            <span id="coins">0</span>
            <div id="coinGainTag"></div>
        </div>
        <div id="diffDisplay" style="font-size: 14px; margin-top: 5px; opacity: 0.7;"></div>
        <div id="shieldStatus"></div>
        <div id="boostStatus"></div>
        <div id="weatherStatus" class="status-line"></div>
        <div id="comboStatus" class="status-line"></div>
        <div id="upgradeStatus" class="status-line"></div>
    </div>
    <div id="orientationHint" role="status" aria-live="polite" aria-hidden="true">Rotate for landscape play</div>
    <div id="mobileControls" aria-hidden="true">
        <button id="boostButton" type="button" aria-label="Trigger speed boost" disabled>Boost</button>
        <div class="mobile-hint">Drag anywhere to steer â€¢ Tap Boost when ready</div>
    </div>
    
    <div id="menu">
        <h1 id="menuTitle">Sky Drifter</h1>
        <div id="versionTag" class="version-pill" role="status" aria-live="polite">Loading version...</div>
        <p id="menuText">Drag your mouse or thumb to fly â€” double tap or hit Boost on phones to sprint.<br>Collect glowing coins and avoid clouds!</p>
        
        <div id="difficultySelector">
            <p style="color: #aaa; margin-bottom: 10px;">Select Difficulty:</p>
            <div id="difficulties"></div>
            <div id="difficultyIndicator" role="status" aria-live="polite"></div>
        </div>
        
        <div id="skinSelector">
            <p style="color: #aaa; margin-bottom: 10px;">Choose your plane:</p>
            <div id="skins"></div>
        </div>

        <button id="startBtn">Play</button>
        
        <div id="hangarPanel">
            <div class="hangar-header">
                <h2>Hangar Upgrades</h2>
                <div id="bankDisplay">Bank: 0</div>
            </div>
            <p class="hangar-note">Coins earned per run are deposited automatically when missions end.</p>
            <div id="upgradeGrid"></div>
        </div>
    </div>

    <script>
    (function() {
        // Canvas setup
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const coinDisplay = document.getElementById('coins');
        const coinIcon = document.getElementById('coinIcon');
        const coinGainTag = document.getElementById('coinGainTag');
        const shieldStatus = document.getElementById('shieldStatus');
        const boostStatus = document.getElementById('boostStatus');
        const weatherStatus = document.getElementById('weatherStatus');
        const comboStatus = document.getElementById('comboStatus');
        const upgradeStatus = document.getElementById('upgradeStatus');
        const diffDisplay = document.getElementById('diffDisplay');
        const menu = document.getElementById('menu');
        const menuTitle = document.getElementById('menuTitle');
        const menuText = document.getElementById('menuText');
        const startBtn = document.getElementById('startBtn');
        const versionTag = document.getElementById('versionTag');
        const bankDisplay = document.getElementById('bankDisplay');
        const upgradeGrid = document.getElementById('upgradeGrid');
        const difficultyIndicator = document.getElementById('difficultyIndicator');
        const bodyElement = document.body;
        const orientationHint = document.getElementById('orientationHint');
        const mobileControls = document.getElementById('mobileControls');
        const boostButton = document.getElementById('boostButton');
        const ORIENTATION_PORTRAIT_CLASS = 'orientation-portrait';
        const ORIENTATION_LANDSCAPE_CLASS = 'orientation-landscape';
        const TOUCH_PRIMARY_CLASS = 'touch-primary';
        const coarsePointerQuery = window.matchMedia ? window.matchMedia('(pointer: coarse)') : null;
        let prefersTouchControls = detectTouchSupport() || (coarsePointerQuery ? coarsePointerQuery.matches : false);
        const defaultMenuTitle = menuTitle ? menuTitle.textContent : '';
        const defaultMenuText = menuText ? menuText.innerHTML : '';
        const VERSION_SOURCE = 'version.json';
        const VERSION_FALLBACK_TEXT = 'Version unavailable';

        function detectTouchSupport() {
            const nav = window.navigator || {};
            return ('ontouchstart' in window) || (nav.maxTouchPoints && nav.maxTouchPoints > 0) || (nav.msMaxTouchPoints && nav.msMaxTouchPoints > 0);
        }

        function updateOrientationHintState(isPortraitOverride) {
            if (!orientationHint) return;
            const isPortrait = typeof isPortraitOverride === 'boolean' ? isPortraitOverride : window.innerHeight >= window.innerWidth;
            const shouldShow = prefersTouchControls && isPortrait;
            orientationHint.classList.toggle('visible', shouldShow);
            orientationHint.setAttribute('aria-hidden', shouldShow ? 'false' : 'true');
            orientationHint.textContent = shouldShow ? 'Rotate for landscape play' : 'Landscape ready';
        }
        
        function updateVersionTag(text) {
            if (versionTag) {
                versionTag.textContent = text;
            }
        }
        
        function loadVersionInfo() {
            if (!versionTag) return;
            if (typeof window.fetch !== 'function') {
                updateVersionTag(VERSION_FALLBACK_TEXT);
                return;
            }
            fetch(VERSION_SOURCE, { cache: 'no-store' })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Version file missing');
                    }
                    return response.json();
                })
                .then(data => {
                    const versionLabel = (data && data.version) ? `Version ${data.version}` : VERSION_FALLBACK_TEXT;
                    updateVersionTag(versionLabel);
                })
                .catch(() => {
                    updateVersionTag(VERSION_FALLBACK_TEXT);
                });
        }
        function applyOrientationMode() {
            if (!bodyElement) return;
            const isPortrait = window.innerHeight >= window.innerWidth;
            bodyElement.classList.toggle(ORIENTATION_PORTRAIT_CLASS, isPortrait);
            bodyElement.classList.toggle(ORIENTATION_LANDSCAPE_CLASS, !isPortrait);
            updateOrientationHintState(isPortrait);
        }
        loadVersionInfo();
        applyOrientationMode();
        if (window.matchMedia) {
            const portraitQuery = window.matchMedia('(orientation: portrait)');
            if (portraitQuery) {
                if (typeof portraitQuery.addEventListener === 'function') {
                    portraitQuery.addEventListener('change', applyOrientationMode);
                } else if (typeof portraitQuery.addListener === 'function') {
                    portraitQuery.addListener(applyOrientationMode);
                }
            }
        }
        window.addEventListener('orientationchange', applyOrientationMode);
        
        function setStatusLine(el, text, mode) {
            if (!el) return;
            el.textContent = text || '';
            el.classList.remove('alert', 'success');
            if (mode) {
                el.classList.add(mode);
            }
        }
        function setWeatherStatusLine(text, mode) {
            setStatusLine(weatherStatus, text, mode);
        }
        function setComboStatusLine(text, mode) {
            setStatusLine(comboStatus, text, mode);
        }
        function setUpgradeStatusLine(text, mode) {
            setStatusLine(upgradeStatus, text, mode);
        }
        setWeatherStatusLine('Skies clear');
        setComboStatusLine('');
        setUpgradeStatusLine('');
        
        const HANGAR_STORAGE_KEY = 'sky_drifter_hangar_v1';
        const DEFAULT_HANGAR_STATE = {
            bank: 0,
            upgrades: {
                engine: 0,
                magnet: 0,
                stability: 0,
                combo: 0
            }
        };
        const UPGRADE_BLUEPRINTS = [
            {
                id: 'engine',
                icon: 'âš¡',
                name: 'Pulse Engines',
                description: 'Higher base airspeed and faster gauntlet recovery.',
                maxLevel: 4,
                baseCost: 35,
                costGrowth: 25
            },
            {
                id: 'magnet',
                icon: 'ðŸ§²',
                name: 'Coin Magnet',
                description: 'Extends coin & combo pickup range.',
                maxLevel: 4,
                baseCost: 30,
                costGrowth: 20
            },
            {
                id: 'stability',
                icon: 'ðŸŒ€',
                name: 'Stability Foils',
                description: 'Reduces weather turbulence on the plane.',
                maxLevel: 3,
                baseCost: 40,
                costGrowth: 35
            },
            {
                id: 'combo',
                icon: 'ðŸŽ¯',
                name: 'Combo Computer',
                description: 'Boosts combo-route payouts.',
                maxLevel: 3,
                baseCost: 50,
                costGrowth: 35
            }
        ];
        
        function cloneDefaultHangar() {
            return JSON.parse(JSON.stringify(DEFAULT_HANGAR_STATE));
        }
        function loadHangarState() {
            const defaults = cloneDefaultHangar();
            if (typeof window === 'undefined' || !window.localStorage) {
                return defaults;
            }
            try {
                const raw = window.localStorage.getItem(HANGAR_STORAGE_KEY);
                if (!raw) return defaults;
                const parsed = JSON.parse(raw);
                return {
                    bank: Math.max(0, parsed.bank || 0),
                    upgrades: Object.assign({}, defaults.upgrades, parsed.upgrades || {})
                };
            } catch (err) {
                return defaults;
            }
        }
        function saveHangarState() {
            if (typeof window === 'undefined' || !window.localStorage) return;
            try {
                window.localStorage.setItem(HANGAR_STORAGE_KEY, JSON.stringify(hangarState));
            } catch (err) {
                // Ignore persistence issues
            }
        }
        
        let hangarState = loadHangarState();
        let lastRunCoins = 0;
        let lastRunScore = 0;
        let upgradeEffects = {
            engineSpeed: 0,
            magnetRadius: 0,
            stabilityMitigation: 0,
            comboBonusMultiplier: 0
        };
        
        function recomputeUpgradeEffects() {
            const engineLevel = hangarState.upgrades.engine || 0;
            const magnetLevel = hangarState.upgrades.magnet || 0;
            const stabilityLevel = hangarState.upgrades.stability || 0;
            const comboLevel = hangarState.upgrades.combo || 0;
            upgradeEffects.engineSpeed = engineLevel * 0.45;
            upgradeEffects.magnetRadius = magnetLevel * 4;
            upgradeEffects.stabilityMitigation = Math.min(0.6, stabilityLevel * 0.18);
            upgradeEffects.comboBonusMultiplier = comboLevel * 0.35;
        }
        recomputeUpgradeEffects();
        
        function updateBankDisplay() {
            if (bankDisplay) {
                bankDisplay.textContent = 'Bank: ' + hangarState.bank;
            }
        }
        updateBankDisplay();
        
        function getUpgradeCost(blueprint, level) {
            return blueprint.baseCost + level * blueprint.costGrowth;
        }
        
        function renderHangarUI() {
            if (!upgradeGrid) return;
            upgradeGrid.innerHTML = '';
            UPGRADE_BLUEPRINTS.forEach(blueprint => {
                const level = hangarState.upgrades[blueprint.id] || 0;
                const maxed = level >= blueprint.maxLevel;
                const cost = maxed ? 0 : getUpgradeCost(blueprint, level);
                const card = document.createElement('div');
                card.className = 'upgrade-card' + (maxed ? ' maxed' : '');
                
                const title = document.createElement('div');
                title.className = 'upgrade-title';
                title.textContent = `${blueprint.icon} ${blueprint.name}`;
                card.appendChild(title);
                
                const levelLine = document.createElement('div');
                levelLine.className = 'upgrade-level';
                levelLine.textContent = `Lv ${level}/${blueprint.maxLevel}`;
                card.appendChild(levelLine);
                
                const desc = document.createElement('p');
                desc.className = 'upgrade-desc';
                desc.textContent = blueprint.description;
                card.appendChild(desc);
                
                const btn = document.createElement('button');
                btn.textContent = maxed ? 'Maxed' : `Upgrade (${cost})`;
                btn.disabled = maxed || hangarState.bank < cost;
                btn.addEventListener('click', () => purchaseUpgrade(blueprint.id));
                card.appendChild(btn);
                
                upgradeGrid.appendChild(card);
            });
        }
        renderHangarUI();
        setUpgradeStatusLine(hangarState.bank ? `Bank ${hangarState.bank} coins ready` : 'Bank empty - earn coins in flight', hangarState.bank ? 'success' : undefined);
        
        function purchaseUpgrade(id) {
            const blueprint = UPGRADE_BLUEPRINTS.find(item => item.id === id);
            if (!blueprint) return;
            const currentLevel = hangarState.upgrades[id] || 0;
            if (currentLevel >= blueprint.maxLevel) {
                setUpgradeStatusLine(`${blueprint.name} already maxed.`, 'alert');
                return;
            }
            const cost = getUpgradeCost(blueprint, currentLevel);
            if (hangarState.bank < cost) {
                setUpgradeStatusLine('Need more banked coins.', 'alert');
                return;
            }
            hangarState.bank -= cost;
            hangarState.upgrades[id] = currentLevel + 1;
            saveHangarState();
            recomputeUpgradeEffects();
            updateBankDisplay();
            renderHangarUI();
            setUpgradeStatusLine(`${blueprint.name} Lv ${currentLevel + 1} equipped`, 'success');
        }
        
        function finalizeRunRewards() {
            const payout = coinsCollected;
            const finalScore = score;
            lastRunCoins = payout;
            lastRunScore = finalScore;
            if (payout > 0) {
                hangarState.bank += payout;
                saveHangarState();
                updateBankDisplay();
                renderHangarUI();
                setUpgradeStatusLine(`Deposited ${payout} coins`, 'success');
            }
            coinsCollected = 0;
            updateCoinDisplay();
            return { coins: payout, score: finalScore };
        }
        
        const WEATHER_EVENTS = [
            {
                id: 'tempest',
                label: 'Tempest Gauntlet',
                duration: 9000,
                worldSpeedScale: 0.9,
                controlSensitivity: 0.85,
                verticalForce: 0.38,
                verticalFrequency: 0.005,
                overlay: 'rgba(25, 35, 78, 0.45)',
                rewardBonus: 2
            },
            {
                id: 'solar',
                label: 'Solar Flare Corridor',
                duration: 8000,
                worldSpeedScale: 1.15,
                controlSensitivity: 1.05,
                verticalForce: 0,
                overlay: 'rgba(255, 196, 0, 0.18)',
                rewardBonus: 3,
                coinBonus: 0.25
            },
            {
                id: 'gust',
                label: 'Gale Tunnel',
                duration: 9500,
                worldSpeedScale: 1,
                controlSensitivity: 0.9,
                verticalForce: 0.25,
                verticalFrequency: 0.0075,
                overlay: 'rgba(120, 200, 255, 0.22)',
                sway: 25,
                rewardBonus: 2
            }
        ];
        const WEATHER_INTERVAL_MIN = 16000;
        const WEATHER_INTERVAL_MAX = 26000;
        let activeWeather = null;
        let nextWeatherAt = 0;
        let weatherCountdownStarted = false;
        
        const COMBO_ROUTE_INTERVAL_MIN = 14000;
        const COMBO_ROUTE_INTERVAL_MAX = 22000;
        const COMBO_CHAIN_TIMEOUT = 1500;
        const COMBO_ROUTE_SPACING_MIN = 160;
        const COMBO_ROUTE_VERTICAL_BASE = 60;
        const COMBO_ROUTE_STEP_LIMIT = 55;
        const COMBO_ROUTE_SMOOTHING = 0.65;
        let comboRoute = null;
        let comboProgress = 0;
        let comboTier = 0;
        let nextComboAt = 0;
        let comboChainExpire = 0;
        
        const JET_ACTIVATION_COIN_THRESHOLD = 10;
        const JET_SPAWN_INTERVAL = 4000;
        const JET_BASE_SPEED = 3;
        const JET_SPEED_VARIANCE = 0.9;
        const JET_SAFE_DISTANCE = 150;
        const JET_SONIC_SPEED = 15;
        const JET_FIRE_INTERVAL_MIN = 900;
        const JET_FIRE_INTERVAL_MAX = 1400;
        const BIG_COIN_VALUE = 5; // 5 coins = 50 points before multiplier
        const BIG_COIN_INTERVAL = 10000;
        const BIG_COIN_CHANCE = 0.45;
        const BIG_COIN_LIMIT = 1;
        const POWERUP_INTERVAL = 14000;
        const POWERUP_LIMIT = 1;
        const SHIELD_DURATION = 5000;
        const SPEED_BOOST_MULTIPLIER = 1.7;
        const SPEED_BOOST_DURATION = 3200;
        const SPEED_BOOST_COOLDOWN = 6000;
        const DOUBLE_TAP_INTERVAL = 300;
        const DOUBLE_TAP_MAX_DISTANCE = 60;
        
        function resize() {
            const viewport = window.visualViewport;
            const width = viewport ? viewport.width : window.innerWidth;
            const height = viewport ? viewport.height : window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        resize();

        // Difficulty settings
        const difficulties = [
            { 
                name: 'Easy', 
                cloudSize: 1.0,      // Normal size
                spawnRate: 2200,     // Spawn every 2.2 seconds
                cloudCount: 1        // 1 cloud per spawn
            },
            { 
                name: 'Medium', 
                cloudSize: 1.4,      // 40% bigger
                spawnRate: 1800,     // Spawn every 1.8 seconds
                cloudCount: 1        // 1 cloud per spawn
            },
            { 
                name: 'Hard', 
                cloudSize: 1.8,      // 80% bigger (big clouds)
                spawnRate: 1400,     // Spawn every 1.4 seconds
                cloudCount: 1        // 1 cloud per spawn
            },
            {
                name: 'Impossible',
                cloudSize: 2.6,          // Humongous clouds
                spawnRate: 900,          // Very frequent spawns
                cloudCount: 3,           // Clouds arrive in waves
                flockLimit: 8,           // Way more airborne threats
                flockInterval: 1700,
                flockBurst: 2,
                fighterJetLimit: 4,
                jetSpawnInterval: 2400,
                jetActivationDelay: 3500
            }
        ];
        const DIFFICULTY_STORAGE_KEY = 'sky_drifter_difficulty_v1';
        const DEFAULT_DIFFICULTY_INDEX = 1;

        function loadDifficultyPreference() {
            if (typeof window === 'undefined' || !window.localStorage) {
                return DEFAULT_DIFFICULTY_INDEX;
            }
            try {
                const stored = window.localStorage.getItem(DIFFICULTY_STORAGE_KEY);
                const parsed = parseInt(stored, 10);
                if (!Number.isNaN(parsed) && parsed >= 0 && parsed < difficulties.length) {
                    return parsed;
                }
            } catch (err) {
                // Ignore preference errors
            }
            return DEFAULT_DIFFICULTY_INDEX;
        }

        function saveDifficultyPreference(index) {
            if (typeof window === 'undefined' || !window.localStorage) return;
            try {
                window.localStorage.setItem(DIFFICULTY_STORAGE_KEY, String(index));
            } catch (err) {
                // Ignore persistence failures
            }
        }

        let selectedDifficulty = loadDifficultyPreference();

        // Create difficulty selector
        function createDifficultySelector() {
            const container = document.getElementById('difficulties');
            container.innerHTML = '';
            
            difficulties.forEach((diff, index) => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'diff-btn ' + diff.name.toLowerCase() + (index === selectedDifficulty ? ' selected' : '');
                btn.textContent = diff.name;
                btn.setAttribute('aria-pressed', index === selectedDifficulty ? 'true' : 'false');
                btn.onclick = function() {
                    selectedDifficulty = index;
                    document.querySelectorAll('.diff-btn').forEach(b => {
                        b.classList.remove('selected');
                        b.setAttribute('aria-pressed', 'false');
                    });
                    btn.classList.add('selected');
                    btn.setAttribute('aria-pressed', 'true');
                    saveDifficultyPreference(index);
                    updateDifficultyIndicator();
                };
                container.appendChild(btn);
            });
        }
        createDifficultySelector();

        function updateDifficultyIndicator() {
            if (!difficultyIndicator) return;
            const diff = difficulties[selectedDifficulty];
            const multiplierLabel = 'x' + (selectedDifficulty + 1) + ' points';
            difficultyIndicator.dataset.difficulty = diff.name.toLowerCase();
            difficultyIndicator.innerHTML = `<strong>${diff.name}</strong> Â· ${multiplierLabel}`;
        }
        updateDifficultyIndicator();

        // Plane skins
        const planeSkins = [
            { name: 'Classic', body: '#e0e0e0', wings: '#4ecdc4', tail: '#ff6b6b', cockpit: '#2c3e50' },
            { name: 'Sunset', body: '#ffb347', wings: '#ff6b6b', tail: '#ff4757', cockpit: '#2f3542' },
            { name: 'Ocean', body: '#74b9ff', wings: '#0984e3', tail: '#00cec9', cockpit: '#2d3436' },
            { name: 'Forest', body: '#a8e6cf', wings: '#56ab2f', tail: '#f093fb', cockpit: '#2d3436' },
            { name: 'Stealth', body: '#2d3436', wings: '#636e72', tail: '#b2bec3', cockpit: '#dfe6e9' },
            { name: 'Gold', body: '#ffd700', wings: '#ff8c00', tail: '#ff6348', cockpit: '#2f3542' },
            { name: 'Cotton Candy', body: '#fd79a8', wings: '#a29bfe', tail: '#74b9ff', cockpit: '#2d3436' },
            { name: 'Midnight', body: '#6c5ce7', wings: '#a29bfe', tail: '#fd79a8', cockpit: '#dfe6e9' },
            { name: 'Harvest Glow', body: '#c97b25', wings: '#f4a261', tail: '#ffe194', cockpit: '#2d3436' },
            { name: 'Cranberry Spice', body: '#8c1c13', wings: '#d17a22', tail: '#f6bd60', cockpit: '#1b1b1b' },
            { name: 'Pumpkin Pie', body: '#d35400', wings: '#f39c12', tail: '#f8c291', cockpit: '#2c3e50' }
        ];
        const SKIN_STORAGE_KEY = 'sky_drifter_skin_v1';
        const DEFAULT_SKIN_INDEX = 0;

        function loadSkinPreference() {
            if (typeof window === 'undefined' || !window.localStorage) {
                return DEFAULT_SKIN_INDEX;
            }
            try {
                const stored = window.localStorage.getItem(SKIN_STORAGE_KEY);
                const parsed = parseInt(stored, 10);
                if (!Number.isNaN(parsed) && parsed >= 0 && parsed < planeSkins.length) {
                    return parsed;
                }
            } catch (err) {
                // Ignore preference errors
            }
            return DEFAULT_SKIN_INDEX;
        }

        function saveSkinPreference(index) {
            if (typeof window === 'undefined' || !window.localStorage) return;
            try {
                window.localStorage.setItem(SKIN_STORAGE_KEY, String(index));
            } catch (err) {
                // Ignore persistence failures
            }
        }

        let selectedSkin = loadSkinPreference();

        // Cloud colors
        const cloudColors = [
            { fill: 'rgba(255, 255, 255, 0.9)', shadow: 'rgba(200, 200, 220, 0.5)' },
            { fill: 'rgba(255, 182, 193, 0.85)', shadow: 'rgba(255, 130, 150, 0.4)' },    // Pink
            { fill: 'rgba(173, 216, 230, 0.85)', shadow: 'rgba(100, 180, 220, 0.4)' },    // Light blue
            { fill: 'rgba(255, 218, 185, 0.85)', shadow: 'rgba(255, 180, 130, 0.4)' },    // Peach
            { fill: 'rgba(221, 160, 221, 0.85)', shadow: 'rgba(180, 120, 180, 0.4)' },    // Plum
            { fill: 'rgba(176, 224, 230, 0.85)', shadow: 'rgba(130, 190, 200, 0.4)' },    // Powder blue
            { fill: 'rgba(255, 250, 205, 0.85)', shadow: 'rgba(230, 220, 150, 0.4)' },    // Lemon
            { fill: 'rgba(152, 251, 152, 0.85)', shadow: 'rgba(100, 200, 100, 0.4)' }     // Pale green
        ];

        // Create skin selector buttons
        function createSkinSelector() {
            const container = document.getElementById('skins');
            container.innerHTML = '';
            
            planeSkins.forEach((skin, index) => {
                const btn = document.createElement('div');
                btn.className = 'skin-btn' + (index === selectedSkin ? ' selected' : '');
                btn.title = skin.name;
                
                // Create mini canvas for preview
                const miniCanvas = document.createElement('canvas');
                miniCanvas.width = 70;
                miniCanvas.height = 50;
                const mctx = miniCanvas.getContext('2d');
                
                // Draw mini plane
                mctx.translate(35, 25);
                mctx.scale(0.5, 0.5);
                
                // Body
                mctx.fillStyle = skin.body;
                mctx.fillRect(-35, -8, 70, 16);
                mctx.beginPath();
                mctx.moveTo(35, -8);
                mctx.lineTo(50, 0);
                mctx.lineTo(35, 8);
                mctx.fill();
                
                // Wings
                mctx.fillStyle = skin.wings;
                mctx.beginPath();
                mctx.moveTo(-10, -8);
                mctx.lineTo(-25, -30);
                mctx.lineTo(10, -8);
                mctx.fill();
                mctx.beginPath();
                mctx.moveTo(-10, 8);
                mctx.lineTo(-25, 30);
                mctx.lineTo(10, 8);
                mctx.fill();
                
                // Tail
                mctx.fillStyle = skin.tail;
                mctx.beginPath();
                mctx.moveTo(-35, -5);
                mctx.lineTo(-45, -20);
                mctx.lineTo(-30, -5);
                mctx.fill();
                
                // Cockpit
                mctx.fillStyle = skin.cockpit;
                mctx.beginPath();
                mctx.arc(20, 0, 8, 0, Math.PI * 2);
                mctx.fill();
                
                btn.appendChild(miniCanvas);
                btn.onclick = function() {
                    selectedSkin = index;
                    document.querySelectorAll('.skin-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    saveSkinPreference(index);
                };
                container.appendChild(btn);
            });
        }
        createSkinSelector();

        // Game state
        let playing = false;
        let score = 0;
        let speed = 3;
        
        function syncMobileComfortUI() {
            if (!mobileControls) return;
            const activate = prefersTouchControls && playing;
            mobileControls.classList.toggle('active', activate);
            mobileControls.setAttribute('aria-hidden', activate ? 'false' : 'true');
        }
        
        function applyTouchPreference(shouldUseTouch) {
            prefersTouchControls = !!shouldUseTouch;
            if (bodyElement) {
                bodyElement.classList.toggle(TOUCH_PRIMARY_CLASS, prefersTouchControls);
            }
            syncMobileComfortUI();
            updateOrientationHintState();
        }
        
        applyTouchPreference(prefersTouchControls);
        if (coarsePointerQuery) {
            const handlePointerPreferenceChange = (event) => {
                applyTouchPreference(event.matches || detectTouchSupport());
            };
            if (typeof coarsePointerQuery.addEventListener === 'function') {
                coarsePointerQuery.addEventListener('change', handlePointerPreferenceChange);
            } else if (typeof coarsePointerQuery.addListener === 'function') {
                coarsePointerQuery.addListener(handlePointerPreferenceChange);
            }
        }
        
        const PLANE_X_RATIO = 0.38;
        const DAMAGE_EFFECT_DURATION = 600;
        
        // Player plane
        let plane = { x: canvas.width * PLANE_X_RATIO, y: canvas.height / 2, vy: 0 };
        let burstEffects = [];
        let screenFlashAlpha = 0;
        let coinGainTimeout = null;
        let shieldActive = false;
        let shieldExpiresAt = 0;
        let speedBoostActive = false;
        let speedBoostEndsAt = 0;
        let speedBoostCooldownUntil = 0;
        let speedBoostStartedAt = 0;
        let lastTapTime = 0;
        let lastTapX = null;
        let lastTapY = null;
        
        function resetPlanePosition() {
            plane.x = canvas.width * PLANE_X_RATIO;
            plane.y = canvas.height / 2;
            plane.vy = 0;
        }
        resetPlanePosition();

        function handleViewportResize() {
            resize();
            applyOrientationMode();
            if (!playing) {
                resetPlanePosition();
            }
        }
        
        window.addEventListener('resize', handleViewportResize);
        if (window.visualViewport && typeof window.visualViewport.addEventListener === 'function') {
            window.visualViewport.addEventListener('resize', handleViewportResize);
        }
        
        // Objects
        let clouds = [];
        let stars = [];
        let bigCoins = [];
        let powerups = [];
        let gooseFlocks = [];
        let fighterJets = [];
        let missiles = [];
        
        const SMALL_COIN_RADIUS = 16;
        const BIG_COIN_BASE_RADIUS = 26;
        const SMALL_COIN_PICKUP_PADDING = 14;
        const BIG_COIN_PICKUP_PADDING = 16;
        // Color palettes for migrating geese formations
        const GOOSE_VARIANTS = [
            {
                body: '#f5f5f0',
                wing: '#cfd6e3',
                belly: '#ffffff',
                neck: '#2f3542',
                head: '#1b1f29',
                beak: '#ffb347',
                accent: '#adb5c1'
            },
            {
                body: '#fdf2dc',
                wing: '#d9c2a7',
                belly: '#fff7ea',
                neck: '#4a3728',
                head: '#2f2115',
                beak: '#ffcb69',
                accent: '#b08968'
            },
            {
                body: '#e6f5ff',
                wing: '#b4c8d5',
                belly: '#f8fdff',
                neck: '#1f2a38',
                head: '#111a24',
                beak: '#ffd479',
                accent: '#90a5b4'
            }
        ];
        
        let coinsCollected = 0;
        let totalStarsCollected = 0;
        let currentMultiplier = 1;
        let jetsActive = false;
        updateCoinDisplay();
        
        let lastGooseFlock = 0;
        let lastFighterJet = 0;
        let lastBigCoin = 0;
        let lastPowerup = 0;
        let jetActivationStart = 0;
        const GEESE_FLOCK_LIMIT = 2;
        const FIGHTER_JET_LIMIT = 2;
        const BASE_GOOSE_INTERVAL = 5000;
        
        function updateScoreDisplay() {
            document.getElementById('score').textContent = score;
        }

        function updateCoinDisplay() {
            if (coinDisplay) {
                coinDisplay.textContent = coinsCollected;
            }
        }

        function pulseCoinIcon() {
            if (!coinIcon) return;
            coinIcon.classList.remove('pop');
            void coinIcon.offsetWidth;
            coinIcon.classList.add('pop');
        }

        function showCoinGainTag(text, type = 'gain') {
            if (!coinGainTag) return;
            coinGainTag.textContent = text;
            coinGainTag.classList.remove('visible');
            coinGainTag.classList.remove('loss');
            if (type === 'loss') {
                coinGainTag.classList.add('loss');
            }
            void coinGainTag.offsetWidth;
            coinGainTag.classList.add('visible');
            if (coinGainTimeout) clearTimeout(coinGainTimeout);
            coinGainTimeout = setTimeout(() => {
                coinGainTag.classList.remove('visible');
            }, 650);
        }

        function awardCoins(amount, time, options = {}) {
            if (amount <= 0) return;
            const skipWeatherBonus = options.skipWeatherBonus;
            const weatherBonus = (!skipWeatherBonus && activeWeather && activeWeather.coinBonus)
                ? Math.max(1, Math.round(amount * activeWeather.coinBonus))
                : 0;
            const totalAward = amount + weatherBonus;
            const prevTotal = totalStarsCollected;
            coinsCollected += totalAward;
            totalStarsCollected += totalAward;
            score = coinsCollected * 10 * currentMultiplier;
            triggerCoinGainEffect(
                options.sourceX !== undefined ? options.sourceX : plane.x,
                options.sourceY !== undefined ? options.sourceY : plane.y,
                totalAward * 10 * currentMultiplier,
                time
            );
            updateScoreDisplay();
            updateCoinDisplay();
            pulseCoinIcon();
            showCoinGainTag(options.coinTagText || ('+' + totalAward));
            const prevSteps = Math.floor(prevTotal / 5);
            const currentSteps = Math.floor(totalStarsCollected / 5);
            const gainedSteps = currentSteps - prevSteps;
            if (gainedSteps > 0) {
                const maxSpeed = 10 + upgradeEffects.engineSpeed;
                speed = Math.min(speed + 0.5 * gainedSteps, maxSpeed);
            }
        }

        function setShieldStatus(text) {
            if (shieldStatus) {
                shieldStatus.textContent = text || '';
            }
        }
        
        function setBoostStatus(text) {
            if (boostStatus) {
                boostStatus.textContent = text || '';
            }
        }
        
        function updateMobileBoostButton(state = {}) {
            if (!boostButton) return;
            const label = state.label || 'Boost';
            boostButton.textContent = label;
            boostButton.disabled = !!state.disabled;
            boostButton.setAttribute('aria-label', state.ariaLabel || label);
        }

        function activateShield(time) {
            shieldActive = true;
            shieldExpiresAt = time + SHIELD_DURATION;
            setShieldStatus('Shield ready');
            triggerBurstEffect({
                x: plane.x,
                y: plane.y,
                color: '#4ecdc4',
                textColor: '#e0fffb',
                label: 'Shield!',
                type: 'reward'
            }, time);
        }

        function deactivateShield() {
            shieldActive = false;
            shieldExpiresAt = 0;
            setShieldStatus('');
        }
        
        function resetSpeedBoostState(now = 0) {
            speedBoostActive = false;
            speedBoostEndsAt = 0;
            speedBoostCooldownUntil = now;
            speedBoostStartedAt = 0;
            lastTapTime = 0;
            lastTapX = null;
            lastTapY = null;
            updateMobileBoostButton({ label: 'Boost', disabled: true, ariaLabel: 'Boost unavailable' });
            if (!playing) {
                setBoostStatus('');
            }
        }
        
        function tryActivateSpeedBoost(time) {
            if (!playing || speedBoostActive || time < speedBoostCooldownUntil) return false;
            speedBoostActive = true;
            speedBoostEndsAt = time + SPEED_BOOST_DURATION;
            speedBoostCooldownUntil = speedBoostEndsAt + SPEED_BOOST_COOLDOWN;
            speedBoostStartedAt = time;
            triggerBurstEffect({
                x: plane.x,
                y: plane.y,
                color: '#74b9ff',
                textColor: '#e8f2ff',
                label: 'Boost!',
                type: 'reward'
            }, time);
            return true;
        }
        
        if (boostButton) {
            boostButton.addEventListener('click', () => {
                if (boostButton.disabled) return;
                tryActivateSpeedBoost(performance.now());
            });
        }
        
        function updateSpeedBoostState(time) {
            if (!playing) {
                speedBoostActive = false;
                speedBoostStartedAt = 0;
                return;
            }
            if (speedBoostActive && time >= speedBoostEndsAt) {
                speedBoostActive = false;
                speedBoostStartedAt = 0;
            }
        }
        
        function updateBoostStatus(time) {
            if (!boostStatus && !boostButton) return;
            if (!playing) {
                setBoostStatus('');
                updateMobileBoostButton({ label: 'Boost', disabled: true, ariaLabel: 'Boost unavailable' });
                return;
            }
            if (speedBoostActive) {
                const remaining = Math.max(speedBoostEndsAt - time, 0);
                const seconds = (remaining / 1000).toFixed(1);
                const label = 'Boost ' + seconds + 's';
                setBoostStatus(label);
                updateMobileBoostButton({ label, disabled: true, ariaLabel: `Boost active ${seconds} seconds remaining` });
                return;
            }
            const cooldownRemaining = Math.max(speedBoostCooldownUntil - time, 0);
            if (cooldownRemaining > 0) {
                const seconds = (cooldownRemaining / 1000).toFixed(1);
                setBoostStatus('Boost CD ' + seconds + 's');
                updateMobileBoostButton({ label: `Ready in ${seconds}s`, disabled: true, ariaLabel: `Boost cooldown ${seconds} seconds remaining` });
            } else {
                setBoostStatus('Double tap ready');
                updateMobileBoostButton({ label: 'Boost Ready', disabled: false, ariaLabel: 'Boost ready' });
            }
        }
        
        function handleTapGesture(x, y, time) {
            if (!playing) return;
            if (lastTapTime && (time - lastTapTime) <= DOUBLE_TAP_INTERVAL) {
                const dx = x - (lastTapX ?? x);
                const dy = y - (lastTapY ?? y);
                const distance = Math.hypot(dx, dy);
                if (distance <= DOUBLE_TAP_MAX_DISTANCE) {
                    tryActivateSpeedBoost(time);
                }
            }
            lastTapTime = time;
            lastTapX = x;
            lastTapY = y;
        }

        function handleShieldBlock(label, time) {
            triggerBurstEffect({
                x: plane.x,
                y: plane.y,
                color: '#4ecdc4',
                textColor: '#e0fffb',
                label: label || 'Blocked',
                type: 'reward'
            }, time);
        }

        function randomInRange(min, max) {
            return min + Math.random() * (max - min);
        }
        
        function randomWeatherDelay() {
            return WEATHER_INTERVAL_MIN + Math.random() * (WEATHER_INTERVAL_MAX - WEATHER_INTERVAL_MIN);
        }
        function scheduleNextWeather(time) {
            nextWeatherAt = time + randomWeatherDelay();
            weatherCountdownStarted = true;
        }
        function startWeatherEvent(time) {
            const blueprint = WEATHER_EVENTS[Math.floor(Math.random() * WEATHER_EVENTS.length)];
            const turbulenceScale = Math.max(0.25, 1 - upgradeEffects.stabilityMitigation);
            const adjustedControl = blueprint.controlSensitivity + (1 - blueprint.controlSensitivity) * upgradeEffects.stabilityMitigation;
            activeWeather = Object.assign({}, blueprint, {
                startedAt: time,
                endsAt: time + blueprint.duration,
                controlSensitivity: adjustedControl,
                verticalForce: (blueprint.verticalForce || 0) * turbulenceScale
            });
            setWeatherStatusLine(`${blueprint.label}!`, 'alert');
        }
        function endWeatherEvent(time) {
            if (!activeWeather) return;
            const reward = Math.max(1, (activeWeather.rewardBonus || 1) + selectedDifficulty);
            const label = activeWeather.label;
            const stillPlaying = playing;
            activeWeather = null;
            if (stillPlaying) {
                awardCoins(reward, time, { coinTagText: `+${reward} ${label}`, skipWeatherBonus: true });
            }
            setWeatherStatusLine('Skies clear', 'success');
            scheduleNextWeather(time);
        }
        
        function ensureWeatherTimeline(time) {
            if (!playing) return;
            if (!weatherCountdownStarted) {
                scheduleNextWeather(time);
            }
            if (!activeWeather && time >= nextWeatherAt) {
                startWeatherEvent(time);
            } else if (activeWeather && time >= activeWeather.endsAt) {
                endWeatherEvent(time);
            }
        }
        
        function comboIntervalDelay() {
            return COMBO_ROUTE_INTERVAL_MIN + Math.random() * (COMBO_ROUTE_INTERVAL_MAX - COMBO_ROUTE_INTERVAL_MIN);
        }
        function resetComboTimeline(time) {
            comboRoute = null;
            comboProgress = 0;
            comboChainExpire = 0;
            nextComboAt = time + comboIntervalDelay();
            setComboStatusLine('Route calibrating', '');
        }
        function spawnComboRoute(time) {
            const count = 4 + selectedDifficulty;
            const spacing = Math.max(COMBO_ROUTE_SPACING_MIN, canvas.width / (count + 1.5));
            const minY = 80;
            const maxY = canvas.height - 80;
            const baseY = randomInRange(minY + 40, maxY - 40);
            const verticalAmplitude = COMBO_ROUTE_VERTICAL_BASE + selectedDifficulty * 6;
            const nodes = [];
            let currentY = baseY;
            const waveOffset = Math.random() * Math.PI * 2;
            // Build a gently sweeping path so combos feel more attainable
            for (let i = 0; i < count; i++) {
                const progress = count > 1 ? i / (count - 1) : 0;
                const wave = Math.sin(progress * Math.PI * 1.15 + waveOffset) * verticalAmplitude;
                const nudge = randomInRange(-verticalAmplitude * 0.35, verticalAmplitude * 0.35);
                let desiredY = baseY + wave + nudge;
                desiredY = Math.min(maxY, Math.max(minY, desiredY));
                if (i === 0) {
                    currentY = desiredY;
                } else {
                    const delta = desiredY - currentY;
                    const limitedDelta = Math.max(-COMBO_ROUTE_STEP_LIMIT, Math.min(COMBO_ROUTE_STEP_LIMIT, delta));
                    currentY += limitedDelta * COMBO_ROUTE_SMOOTHING;
                }
                currentY = Math.min(maxY, Math.max(minY, currentY));
                nodes.push({
                    x: canvas.width + 80 + i * spacing,
                    y: currentY,
                    collected: false
                });
            }
            comboRoute = {
                nodes,
                startedAt: time,
                expiresAt: time + 9000,
                highlightSeed: Math.random() * Math.PI
            };
            comboProgress = 0;
            comboChainExpire = comboRoute.expiresAt;
            nextComboAt = Number.POSITIVE_INFINITY;
            setComboStatusLine(`Combo route online (${count} nodes)`, 'alert');
        }
        function updateComboRoutePositions(worldSpeed, time) {
            if (!comboRoute) return;
            const moveSpeed = worldSpeed + 1.8;
            let offscreen = 0;
            comboRoute.nodes.forEach(node => {
                node.x -= moveSpeed;
                if (node.x < -120) {
                    offscreen++;
                }
            });
            if (offscreen > 0 && comboProgress < comboRoute.nodes.length) {
                failComboRoute('Route lost', time);
            }
        }
        function completeComboRoute(time) {
            if (!comboRoute) return;
            comboTier = Math.min(comboTier + 1, 5);
            const baseReward = comboRoute.nodes.length + comboTier * 2;
            const bonus = Math.round(baseReward * upgradeEffects.comboBonusMultiplier);
            const payout = baseReward + bonus;
            setComboStatusLine(`Combo x${comboTier}!`, 'success');
            comboRoute = null;
            comboProgress = 0;
            comboChainExpire = 0;
            nextComboAt = time + comboIntervalDelay();
            awardCoins(payout, time, { coinTagText: `+${payout} combo`, skipWeatherBonus: true });
        }
        function failComboRoute(reason, time) {
            comboRoute = null;
            comboProgress = 0;
            comboChainExpire = 0;
            comboTier = Math.max(0, comboTier - 1);
            setComboStatusLine(reason || 'Combo dropped', 'alert');
            const failTime = time || performance.now();
            nextComboAt = failTime + comboIntervalDelay();
        }
        function drawComboRoute(ctx, time) {
            if (!comboRoute) return;
            ctx.save();
            ctx.globalAlpha = 0.45;
            ctx.strokeStyle = 'rgba(255, 200, 92, 0.55)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            comboRoute.nodes.forEach((node, idx) => {
                if (idx === 0) {
                    ctx.moveTo(node.x, node.y);
                } else {
                    ctx.lineTo(node.x, node.y);
                }
            });
            ctx.stroke();
            ctx.globalAlpha = 1;
            comboRoute.nodes.forEach((node, idx) => {
                ctx.save();
                ctx.translate(node.x, node.y);
                const pulse = 1 + Math.sin((time / 220) + idx + (comboRoute.highlightSeed || 0)) * 0.12;
                const radius = (node.collected ? 12 : 18) + upgradeEffects.magnetRadius * 0.25;
                ctx.beginPath();
                ctx.lineWidth = node.collected ? 1.5 : 3;
                ctx.strokeStyle = node.collected ? 'rgba(255,255,255,0.4)' : 'rgba(255, 196, 77, 0.9)';
                ctx.fillStyle = node.collected ? 'rgba(255,255,255,0.18)' : 'rgba(255, 220, 120, 0.7)';
                ctx.scale(pulse, pulse);
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                if (idx === comboProgress && !node.collected) {
                    ctx.lineWidth = 1.5;
                    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                    ctx.beginPath();
                    ctx.arc(0, 0, radius + 6, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();
            });
        }
        function drawWeatherOverlay(ctx, time) {
            if (!activeWeather) return;
            ctx.save();
            const overlay = activeWeather.overlay || 'rgba(0, 0, 0, 0.18)';
            ctx.fillStyle = overlay;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (activeWeather.id === 'tempest') {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 2; i++) {
                    if (Math.random() < 0.05) {
                        const startX = Math.random() * canvas.width;
                        ctx.beginPath();
                        ctx.moveTo(startX, 0);
                        ctx.lineTo(startX + randomInRange(-40, 40), randomInRange(60, 160));
                        ctx.lineTo(startX + randomInRange(-80, 80), randomInRange(200, 320));
                        ctx.stroke();
                    }
                }
            } else if (activeWeather.id === 'gust') {
                ctx.strokeStyle = 'rgba(180, 220, 255, 0.25)';
                ctx.lineWidth = 1.5;
                for (let y = 0; y < canvas.height; y += 40) {
                    ctx.beginPath();
                    ctx.moveTo(0, y + Math.sin((time / 600) + y) * 12);
                    ctx.lineTo(canvas.width, y + Math.cos((time / 500) + y) * 12);
                    ctx.stroke();
                }
            } else if (activeWeather.id === 'solar') {
                const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width);
                gradient.addColorStop(0, 'rgba(255, 240, 200, 0.25)');
                gradient.addColorStop(1, 'rgba(255, 165, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            ctx.restore();
        }
        
        function triggerBurstEffect(effect, time) {
            burstEffects.push({
                x: effect.x,
                y: effect.y,
                color: effect.color,
                label: effect.label,
                textColor: effect.textColor,
                type: effect.type || 'damage',
                start: time
            });
            if (effect.type !== 'reward') {
                screenFlashAlpha = 0.45;
            }
        }
        
        // Shared sonic trail used for both jets and player boosts
        function drawSpeedTrail(ctx, alpha = 0.8) {
            const clampedAlpha = Math.max(0, Math.min(alpha, 1));
            const trailGradient = ctx.createLinearGradient(-130, 0, -5, 0);
            trailGradient.addColorStop(0, 'rgba(148, 255, 255, 0)');
            trailGradient.addColorStop(1, 'rgba(148, 255, 255,' + clampedAlpha + ')');
            ctx.fillStyle = trailGradient;
            ctx.beginPath();
            ctx.moveTo(-130, -18);
            ctx.lineTo(-15, -6);
            ctx.lineTo(-15, 6);
            ctx.lineTo(-130, 18);
            ctx.closePath();
            ctx.fill();
        }
        
        // Draw a single goose used to compose migrating flocks
        function drawMigratingGoose(ctx, palette, wingPhase, scale = 1) {
            const wingBeat = Math.sin(wingPhase) * 0.5;
            ctx.save();
            ctx.scale(scale, scale);
            ctx.scale(-1, 1);
            
            ctx.fillStyle = palette.wing;
            const drawWing = (direction = 1) => {
                const angleOffset = wingBeat * 0.35;
                const wingLength = 32 + wingBeat * 6;
                ctx.save();
                ctx.translate(-6, 0);
                // Keep wings perpendicular to the body axis and let the flap slightly tilt them
                ctx.rotate(direction * (Math.PI / 2 + angleOffset));
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(-wingLength * 0.35, -6, -wingLength, 0);
                ctx.quadraticCurveTo(-wingLength * 0.35, 6, 0, 0);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            };
            drawWing(-1);
            drawWing(1);
            
            ctx.fillStyle = palette.body;
            ctx.beginPath();
            ctx.ellipse(-6, 0, 18, 7.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = palette.belly;
            ctx.beginPath();
            ctx.ellipse(-8, 2, 14, 4.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = palette.accent;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-18, 3);
            ctx.lineTo(2, 2);
            ctx.stroke();
            
            ctx.fillStyle = palette.accent;
            ctx.beginPath();
            ctx.moveTo(-18, -2);
            ctx.lineTo(-26, -8);
            ctx.lineTo(-24, 4);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = palette.neck;
            ctx.beginPath();
            ctx.moveTo(0, -2);
            ctx.quadraticCurveTo(14, -4 - wingBeat * 2, 16, -2);
            ctx.lineTo(16, 2);
            ctx.quadraticCurveTo(0, 2 + wingBeat * 2, 0, 0);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = palette.head;
            ctx.beginPath();
            ctx.ellipse(18, -1, 4.3, 3.2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = palette.beak;
            ctx.beginPath();
            ctx.moveTo(22, -1);
            ctx.lineTo(30, -0.5);
            ctx.lineTo(22, 2.2);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(17.2, -2.2, 0.9, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#111';
            ctx.beginPath();
            ctx.arc(17.5, -2.2, 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Render a migrating flock with a subtle V formation
        function drawGooseFlockSprite(ctx, flock, time) {
            if (!flock || !flock.geese || flock.geese.length === 0) return;
            const palette = flock.palette || GOOSE_VARIANTS[0];
            const wingBase = (time / 220) + (flock.flapOffset || 0);
            const scale = flock.scale || 1;
            
            ctx.rotate(flock.glideTilt || 0);
            
            if (flock.geese.length > 1) {
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.08 + (flock.ribbonAlpha || 0.1)})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                const leftMost = flock.geese.reduce((acc, bird) => {
                    if (!acc || bird.xOffset < acc.xOffset) return bird;
                    return acc;
                }, null);
                const rightMost = flock.geese.reduce((acc, bird) => {
                    if (!acc || bird.xOffset > acc.xOffset) return bird;
                    return acc;
                }, null);
                if (leftMost) {
                    ctx.lineTo(leftMost.xOffset * scale * 1.05, leftMost.yOffset * scale * 1.05);
                    ctx.moveTo(0, 0);
                }
                if (rightMost) {
                    ctx.lineTo(rightMost.xOffset * scale * 1.05, rightMost.yOffset * scale * 1.05);
                }
                ctx.stroke();
            }
            
            for (let i = 0; i < flock.geese.length; i++) {
                const goose = flock.geese[i];
                ctx.save();
                const bob = Math.sin((time / 260) + (goose.phase || 0)) * (goose.bob || 1.2);
                ctx.translate(goose.xOffset * scale, (goose.yOffset + bob) * scale);
                const gooseScale = (goose.scale || 1) * scale;
                drawMigratingGoose(ctx, palette, wingBase + (goose.phase || 0), gooseScale);
                ctx.restore();
            }
        }

        function startJetEscape(jet, time) {
            if (jet.evading) return;
            jet.evading = true;
            jet.escapeStart = time;
            jet.speed = JET_SONIC_SPEED;
            jet.shotInterval = Infinity;
            jet.lastShot = time;
            triggerBurstEffect({
                x: jet.x,
                y: jet.y,
                color: '#4ecdc4',
                textColor: '#d7fff7',
                label: 'Sonic!',
                type: 'reward'
            }, time);
        }
        
        function triggerCoinGainEffect(x, y, amount, time) {
            triggerBurstEffect({
                x,
                y,
                color: '#ffd700',
                textColor: '#fff3b0',
                label: '+' + amount,
                type: 'reward'
            }, time);
        }
        
        function applyCoinDamage(options, time) {
            if (shieldActive) {
                handleShieldBlock('Shielded', time);
                return;
            }
            const { amount = 0, all = false, color = '#ff6b6b', label } = options || {};
            const before = coinsCollected;
            coinsCollected = all ? 0 : Math.max(0, coinsCollected - amount);
            score = coinsCollected * 10 * currentMultiplier;
            updateScoreDisplay();
            updateCoinDisplay();
            const lost = Math.max(before - coinsCollected, 0);
            if (lost > 0) {
                pulseCoinIcon();
                showCoinGainTag('-' + lost, 'loss');
            }
            const displayLabel = label || (all ? 'All!' : `-${lost || amount}`);
            triggerBurstEffect({ x: plane.x, y: plane.y, color, label: displayLabel, type: 'damage' }, time);
        }

        function handlePlayerDeath(reason) {
            if (!playing) return;
            playing = false;
            jetsActive = false;
            missiles = [];
            fighterJets = [];
            gooseFlocks = [];
            clouds = [];
            stars = [];
            bigCoins = [];
            powerups = [];
            burstEffects = [];
            screenFlashAlpha = 0;
            deactivateShield();
            const now = performance.now();
            resetSpeedBoostState(now);
            const runResults = finalizeRunRewards();
            activeWeather = null;
            weatherCountdownStarted = false;
            setWeatherStatusLine('Skies clear');
            comboRoute = null;
            comboProgress = 0;
            comboChainExpire = 0;
            nextComboAt = Number.POSITIVE_INFINITY;
            setComboStatusLine('');
            if (menuTitle) menuTitle.textContent = 'Mission Failed';
            if (menuText) {
                menuText.innerHTML = `${reason}<br><br>Coins: ${runResults.coins}<br>Score: ${runResults.score}`;
            }
            if (startBtn) startBtn.textContent = 'Play Again';
            if (menu) menu.classList.remove('hidden');
            syncMobileComfortUI();
        }
        
        // Controls
        let up = false, down = false;
        let targetY = null; // For mouse/touch control
        
        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowUp' || e.key === 'w') up = true;
            if (e.key === 'ArrowDown' || e.key === 's') down = true;
        });
        
        document.addEventListener('keyup', function(e) {
            if (e.key === 'ArrowUp' || e.key === 'w') up = false;
            if (e.key === 'ArrowDown' || e.key === 's') down = false;
        });
        
        // Mouse controls
        canvas.addEventListener('mousemove', function(e) {
            targetY = e.clientY;
        });
        
        canvas.addEventListener('mousedown', function(e) {
            targetY = e.clientY;
            if (e.button === 0) {
                handleTapGesture(e.clientX, e.clientY, performance.now());
            }
        });
        
        canvas.addEventListener('mouseleave', function() {
            targetY = null;
        });
        
        // Touch controls
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                targetY = touch.clientY;
                handleTapGesture(touch.clientX, touch.clientY, performance.now());
            }
        }, { passive: false });
        
        canvas.addEventListener('touchmove', function(e) {
            e.preventDefault();
            if (e.touches.length > 0) {
                targetY = e.touches[0].clientY;
            }
        }, { passive: false });
        
        canvas.addEventListener('touchend', function(e) {
            targetY = null;
        });

        // Start button
        document.getElementById('startBtn').onclick = function() {
            if (menuTitle) menuTitle.textContent = defaultMenuTitle;
            if (menuText) menuText.innerHTML = defaultMenuText;
            if (startBtn) startBtn.textContent = 'Play';
            playing = true;
            score = 0;
            speed = 3 + upgradeEffects.engineSpeed;
            resetPlanePosition();
            clouds = [];
            stars = [];
            bigCoins = [];
            powerups = [];
            gooseFlocks = [];
            fighterJets = [];
            missiles = [];
            coinsCollected = 0;
            totalStarsCollected = 0;
            jetsActive = false;
            currentMultiplier = selectedDifficulty + 1;
            deactivateShield();
            const now = performance.now();
            resetSpeedBoostState(now);
            updateCoinDisplay();
            if (coinGainTag) {
                coinGainTag.textContent = '';
                coinGainTag.classList.remove('visible', 'loss');
            }
            lastFalcon = now;
            lastFighterJet = now;
            lastBigCoin = now;
            lastPowerup = now;
            jetActivationStart = now;
            activeWeather = null;
            weatherCountdownStarted = false;
            scheduleNextWeather(now);
            comboTier = 0;
            resetComboTimeline(now);
            setWeatherStatusLine('Skies clear');
            setUpgradeStatusLine(`Bank ${hangarState.bank} coins ready`, 'success');
            updateScoreDisplay();
            updateBoostStatus(now);
            
            // Show difficulty and point multiplier
            const diff = difficulties[selectedDifficulty];
            if (diffDisplay) {
                diffDisplay.textContent = `${diff.name} (x${currentMultiplier} points)`;
            }
            
            if (menu) menu.classList.add('hidden');
            syncMobileComfortUI();
        };

        // Spawn timers
        let lastCloud = 0;
        let lastStar = 0;

        // Main loop
        function loop(time) {
            // Clear screen
            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            updateSpeedBoostState(time);
            updateBoostStatus(time);
            
            if (playing) {
                ensureWeatherTimeline(time);
                if (shieldActive) {
                    const remaining = Math.max(shieldExpiresAt - time, 0);
                    if (remaining <= 0) {
                        deactivateShield();
                    } else {
                        setShieldStatus('Shield ' + (remaining / 1000).toFixed(1) + 's');
                    }
                }
                
                // Spawn clouds based on difficulty
                const diff = difficulties[selectedDifficulty];
                const flockInterval = diff.flockInterval ?? diff.gooseInterval ?? diff.falconInterval ?? BASE_GOOSE_INTERVAL;
                const flockLimit = diff.flockLimit ?? diff.gooseLimit ?? diff.falconLimit ?? GEESE_FLOCK_LIMIT;
                const flockBurst = diff.flockBurst ?? diff.gooseBurst ?? diff.falconBurst ?? 1;
                const jetSpawnInterval = diff.jetSpawnInterval || JET_SPAWN_INTERVAL;
                const fighterJetLimit = diff.fighterJetLimit || FIGHTER_JET_LIMIT;
                const jetActivationDelay = (diff.jetActivationDelay !== undefined) ? diff.jetActivationDelay : null;
                const jetActivationCoinThreshold = (diff.jetActivationCoinThreshold !== undefined) ? diff.jetActivationCoinThreshold : JET_ACTIVATION_COIN_THRESHOLD;
                const weatherSpeedScale = activeWeather ? activeWeather.worldSpeedScale : 1;
                const worldSpeed = (speedBoostActive ? speed * SPEED_BOOST_MULTIPLIER : speed) * weatherSpeedScale;
                const magnetBoost = upgradeEffects.magnetRadius;

                if (!comboRoute && time >= nextComboAt) {
                    spawnComboRoute(time);
                } else if (comboRoute && time >= comboRoute.expiresAt) {
                    failComboRoute('Route expired', time);
                }
                updateComboRoutePositions(worldSpeed, time);
                if (comboRoute && comboChainExpire && time >= comboChainExpire) {
                    failComboRoute('Combo window missed', time);
                }

                const controlFactor = activeWeather ? activeWeather.controlSensitivity : 1;

                if (!jetsActive) {
                    const delayElapsed = jetActivationDelay !== null && (time - jetActivationStart) >= jetActivationDelay;
                    const coinsReached = totalStarsCollected >= jetActivationCoinThreshold;
                    if (delayElapsed || coinsReached) {
                        jetsActive = true;
                        lastFighterJet = time - jetSpawnInterval;
                    }
                }
                if (time - lastCloud > diff.spawnRate) {
                    // Spawn multiple clouds based on difficulty
                    for (let i = 0; i < diff.cloudCount; i++) {
                        const colorIndex = Math.floor(Math.random() * cloudColors.length);
                        const size = diff.cloudSize;
                        clouds.push({
                            x: canvas.width + 50 + (i * 100), // Offset multiple clouds
                            y: Math.random() * (canvas.height - 120) + 60,
                            w: 80 * size,
                            h: 50 * size,
                            size: size,
                            color: cloudColors[colorIndex]
                        });
                    }
                    lastCloud = time;
                }
                
                // Spawn stars
                if (time - lastStar > 1500) {
                    stars.push({
                        x: canvas.width + 20,
                        y: Math.random() * (canvas.height - 100) + 50
                    });
                    lastStar = time;
                }
                
                if (time - lastBigCoin > BIG_COIN_INTERVAL) {
                    lastBigCoin = time;
                    if (bigCoins.length < BIG_COIN_LIMIT && Math.random() < BIG_COIN_CHANCE) {
                        bigCoins.push({
                            x: canvas.width + 60,
                            y: Math.random() * (canvas.height - 160) + 80,
                            pulse: Math.random() * Math.PI * 2
                        });
                    }
                }
                
                if (time - lastPowerup > POWERUP_INTERVAL) {
                    lastPowerup = time;
                    if (powerups.length < POWERUP_LIMIT) {
                        powerups.push({
                            x: canvas.width + 60,
                            y: Math.random() * (canvas.height - 140) + 70,
                            type: 'shield',
                            drift: Math.random() * Math.PI * 2,
                            rotation: Math.random() * Math.PI * 2
                        });
                    }
                }
                
                // Spawn migrating goose flocks that drift across the sky
                if (time - lastGooseFlock > flockInterval && gooseFlocks.length < flockLimit) {
                    const availableSlots = Math.max(0, flockLimit - gooseFlocks.length);
                    const spawnCount = Math.min(flockBurst, availableSlots);
                    for (let i = 0; i < spawnCount; i++) {
                        const palette = GOOSE_VARIANTS[Math.floor(Math.random() * GOOSE_VARIANTS.length)];
                        const flockScale = 0.85 + Math.random() * 0.3;
                        const spacingX = randomInRange(32, 46);
                        const spacingY = randomInRange(18, 26);
                        const gooseCount = 3 + Math.floor(Math.random() * 3);
                        const geese = [{
                            xOffset: 0,
                            yOffset: 0,
                            bob: randomInRange(1.4, 2.4),
                            phase: Math.random() * Math.PI * 2,
                            scale: 1
                        }];
                        let remaining = gooseCount - 1;
                        let level = 1;
                        while (remaining > 0) {
                            const baseYOffset = level * spacingY + randomInRange(-4, 4);
                            const basePhase = Math.random() * Math.PI * 2;
                            if (remaining > 0) {
                                geese.push({
                                    xOffset: -level * spacingX,
                                    yOffset: baseYOffset,
                                    bob: randomInRange(0.9, 1.8),
                                    phase: basePhase,
                                    scale: 0.85 + Math.random() * 0.15
                                });
                                remaining--;
                            }
                            if (remaining > 0) {
                                geese.push({
                                    xOffset: level * spacingX,
                                    yOffset: baseYOffset + randomInRange(-3, 3),
                                    bob: randomInRange(0.9, 1.8),
                                    phase: basePhase + randomInRange(0.15, 0.35),
                                    scale: 0.85 + Math.random() * 0.15
                                });
                                remaining--;
                            }
                            level++;
                        }
                        const formationDepth = Math.max(1, Math.ceil(gooseCount / 2));
                        gooseFlocks.push({
                            x: canvas.width + 80 + i * 40,
                            y: Math.random() * (canvas.height - 140) + 70,
                            speed: speed + 1.4 + Math.random() * 1.2,
                            flapOffset: Math.random() * Math.PI * 2,
                            scale: flockScale,
                            glideTilt: randomInRange(-0.05, 0.05),
                            driftPhase: Math.random() * Math.PI * 2,
                            wobble: randomInRange(0.7, 1.5),
                            ribbonAlpha: randomInRange(0.08, 0.16),
                            palette,
                            geese,
                            collisionRadius: 55 + formationDepth * 6
                        });
                    }
                    lastGooseFlock = time;
                }
                
                // Spawn fighter jets from behind once activated
                if (jetsActive && time - lastFighterJet > jetSpawnInterval && fighterJets.length < fighterJetLimit) {
                    const shotInterval = randomInRange(JET_FIRE_INTERVAL_MIN, JET_FIRE_INTERVAL_MAX);
                    fighterJets.push({
                        x: -150,
                        y: Math.random() * (canvas.height - 100) + 50,
                        speed: JET_BASE_SPEED + Math.random() * JET_SPEED_VARIANCE,
                        lastShot: time - shotInterval,
                        shotInterval,
                        evading: false,
                        escapeStart: 0
                    });
                    lastFighterJet = time;
                }
                
                // Update plane
                if (up) plane.vy -= 0.5 * controlFactor;
                if (down) plane.vy += 0.5 * controlFactor;
                
                // Mouse/touch control - plane follows finger/cursor
                if (targetY !== null && !up && !down) {
                    let diff = targetY - plane.y;
                    plane.vy += diff * 0.05 * controlFactor;
                }
                
                plane.vy += 0.15; // gravity (reduced)
                plane.vy *= 0.92; // drag
                if (activeWeather && activeWeather.verticalForce) {
                    const freq = activeWeather.verticalFrequency || 0.004;
                    plane.vy += Math.sin((time - activeWeather.startedAt) * freq) * activeWeather.verticalForce;
                }
                plane.vy = Math.max(-12, Math.min(12, plane.vy)); // limit speed
                plane.y += plane.vy;
                if (activeWeather && activeWeather.sway) {
                    plane.y += Math.sin(time / 600) * (activeWeather.sway * 0.02);
                }
                
                // Bounds
                if (plane.y < 30) { plane.y = 30; plane.vy = 0; }
                if (plane.y > canvas.height - 30) { plane.y = canvas.height - 30; plane.vy = 0; }
                
                // Update clouds
                for (let i = clouds.length - 1; i >= 0; i--) {
                    clouds[i].x -= worldSpeed;
                    if (clouds[i].x < -100) clouds.splice(i, 1);
                }
                
                // Update stars
                for (let i = stars.length - 1; i >= 0; i--) {
                    stars[i].x -= worldSpeed + 1;
                    if (stars[i].x < -20) stars.splice(i, 1);
                }
                
                // Update big coins
                for (let i = bigCoins.length - 1; i >= 0; i--) {
                    const big = bigCoins[i];
                    big.x -= worldSpeed + 0.9;
                    big.pulse = (big.pulse || 0) + 0.05;
                    big.wobble = Math.sin((time / 250) + big.pulse) * 2;
                    if (big.x < -100) {
                        bigCoins.splice(i, 1);
                    }
                }
                
                // Update powerups
                for (let i = powerups.length - 1; i >= 0; i--) {
                    const item = powerups[i];
                    item.x -= worldSpeed + 0.7;
                    item.drift += 0.03;
                    item.y += Math.sin(item.drift) * 0.7;
                    if (item.x < -80) {
                        powerups.splice(i, 1);
                    }
                }
                
                // Update goose flocks and handle collisions
                for (let i = gooseFlocks.length - 1; i >= 0; i--) {
                    const flock = gooseFlocks[i];
                    flock.x -= flock.speed;
                    flock.y += Math.sin((time / 420) + flock.driftPhase) * (flock.wobble || 1);
                    flock.glideTilt = Math.sin((time / 820) + flock.driftPhase) * 0.12;
                    if (flock.x < -200) {
                        gooseFlocks.splice(i, 1);
                        continue;
                    }
                    const dx = plane.x - flock.x;
                    const dy = plane.y - flock.y;
                    const radius = flock.collisionRadius || 60;
                    if (Math.sqrt(dx * dx + dy * dy) < radius) {
                        applyCoinDamage({ all: true, color: '#adc178', label: 'All!' }, time);
                        gooseFlocks.splice(i, 1);
                    }
                }
                
                // Update fighter jets and fire missiles
                for (let i = fighterJets.length - 1; i >= 0; i--) {
                    const jet = fighterJets[i];
                    jet.x += jet.speed;
                    const followStrength = jet.evading ? 0.005 : 0.02;
                    jet.y += (plane.y - jet.y) * followStrength;
                    const distanceToPlane = Math.hypot(plane.x - jet.x, plane.y - jet.y);
                    
                    if (!jet.evading && distanceToPlane < JET_SAFE_DISTANCE) {
                        startJetEscape(jet, time);
                    }
                    
                    if (jet.x > canvas.width + 220) {
                        fighterJets.splice(i, 1);
                        continue;
                    }
                    
                    if (!jet.evading && jet.x < plane.x + 40 && time - jet.lastShot >= jet.shotInterval) {
                        if (distanceToPlane >= JET_SAFE_DISTANCE) {
                            const angle = Math.atan2(plane.y - jet.y, plane.x - jet.x);
                            missiles.push({
                                x: jet.x + 30,
                                y: jet.y,
                                vx: Math.cos(angle) * 6.5,
                                vy: Math.sin(angle) * 6.5,
                                angle: angle
                            });
                            jet.lastShot = time;
                            jet.shotInterval = randomInRange(JET_FIRE_INTERVAL_MIN, JET_FIRE_INTERVAL_MAX);
                        } else {
                            startJetEscape(jet, time);
                        }
                    }
                }
                
                // Update missiles
                for (let i = missiles.length - 1; i >= 0; i--) {
                    const m = missiles[i];
                    m.x += m.vx;
                    m.y += m.vy;
                    if (m.x < -120 || m.x > canvas.width + 120 || m.y < -120 || m.y > canvas.height + 120) {
                        missiles.splice(i, 1);
                        continue;
                    }
                    let dx = plane.x - m.x;
                    let dy = plane.y - m.y;
                    if (Math.sqrt(dx*dx + dy*dy) < 25) {
                        missiles.splice(i, 1);
                        if (shieldActive) {
                            handleShieldBlock('Shielded', time);
                        } else {
                            handlePlayerDeath('A fighter jet missile hit you!');
                            break;
                        }
                    }
                }
                
                // Draw clouds with different colors and sizes
                for (let c of clouds) {
                    const s = c.size || 1;
                    
                    // Shadow
                    ctx.fillStyle = c.color.shadow;
                    ctx.beginPath();
                    ctx.arc(c.x + 5 * s, c.y + 8 * s, 25 * s, 0, Math.PI * 2);
                    ctx.arc(c.x + 30 * s, c.y - 2 * s, 30 * s, 0, Math.PI * 2);
                    ctx.arc(c.x + 55 * s, c.y + 8 * s, 25 * s, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Main cloud
                    ctx.fillStyle = c.color.fill;
                    ctx.beginPath();
                    ctx.arc(c.x, c.y, 25 * s, 0, Math.PI * 2);
                    ctx.arc(c.x + 25 * s, c.y - 10 * s, 30 * s, 0, Math.PI * 2);
                    ctx.arc(c.x + 50 * s, c.y, 25 * s, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw coins (formerly stars) with depth and shine
                for (let s of stars) {
                    const radius = SMALL_COIN_RADIUS;
                    const gradient = ctx.createRadialGradient(s.x - 5, s.y - 6, 4, s.x, s.y, radius);
                    gradient.addColorStop(0, '#fffbd1');
                    gradient.addColorStop(0.45, '#ffe066');
                    gradient.addColorStop(1, '#d9a404');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.55)';
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, radius - 2, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.25)';
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, 6, -Math.PI / 3, Math.PI / 2);
                    ctx.stroke();
                }
                
                // Draw BIG coins
                for (let big of bigCoins) {
                    const radius = BIG_COIN_BASE_RADIUS + Math.sin(big.pulse || 0) * 2;
                    ctx.save();
                    ctx.translate(big.x, big.y + (big.wobble || 0));
                    ctx.rotate(Math.sin((big.pulse || 0) * 0.7) * 0.2);
                    const gradient = ctx.createRadialGradient(-6, -8, 6, 0, 0, radius);
                    gradient.addColorStop(0, '#fff5c3');
                    gradient.addColorStop(0.4, '#ffe066');
                    gradient.addColorStop(1, '#c9960c');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.lineWidth = 4;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.65)';
                    ctx.beginPath();
                    ctx.arc(0, 0, radius - 4, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.25)';
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.18)';
                    ctx.font = 'bold 30px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('50', 0, 0);
                    ctx.restore();
                }
                
                // Draw powerups
                for (let item of powerups) {
                    ctx.save();
                    ctx.translate(item.x, item.y);
                    ctx.rotate((item.rotation || 0) + time / 400);
                    const pulse = 1 + Math.sin((time / 200) + item.drift) * 0.1;
                    ctx.scale(pulse, pulse);
                    ctx.fillStyle = 'rgba(78, 205, 196, 0.25)';
                    ctx.shadowColor = '#4ecdc4';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const x = Math.cos(angle) * 26;
                        const y = Math.sin(angle) * 26;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = '#4ecdc4';
                    ctx.stroke();
                    ctx.fillStyle = '#e0fffb';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('S', 0, 0);
                    ctx.restore();
                }
                
                drawComboRoute(ctx, time);
                
                // Draw migrating goose flocks
                for (let flock of gooseFlocks) {
                    ctx.save();
                    ctx.translate(flock.x, flock.y);
                    drawGooseFlockSprite(ctx, flock, time);
                    ctx.restore();
                }
                
                // Draw fighter jets
                for (let jet of fighterJets) {
                    ctx.save();
                    ctx.translate(jet.x, jet.y);
                    if (jet.evading) {
                        const progress = jet.escapeStart ? Math.min((time - jet.escapeStart) / 600, 1) : 0;
                        drawSpeedTrail(ctx, 0.5 + 0.3 * (1 - progress));
                    }
                    ctx.fillStyle = '#95a5a6';
                    ctx.fillRect(-35, -6, 70, 12);
                    ctx.fillStyle = '#7f8c8d';
                    ctx.beginPath();
                    ctx.moveTo(-35, -6);
                    ctx.lineTo(-55, -18);
                    ctx.lineTo(-10, -6);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(-35, 6);
                    ctx.lineTo(-55, 18);
                    ctx.lineTo(-10, 6);
                    ctx.fill();
                    ctx.fillStyle = '#bdc3c7';
                    ctx.beginPath();
                    ctx.moveTo(35, -6);
                    ctx.lineTo(55, 0);
                    ctx.lineTo(35, 6);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Draw missiles
                for (let m of missiles) {
                    ctx.save();
                    ctx.translate(m.x, m.y);
                    ctx.rotate(m.angle || 0);
                    ctx.fillStyle = '#ff4136';
                    ctx.fillRect(-10, -4, 20, 8);
                    ctx.fillStyle = '#dddddd';
                    ctx.fillRect(6, -3, 6, 6);
                    ctx.fillStyle = '#ffa502';
                    ctx.beginPath();
                    ctx.moveTo(-10, -4);
                    ctx.lineTo(-16, 0);
                    ctx.lineTo(-10, 4);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Draw plane with selected skin
                const skin = planeSkins[selectedSkin];
                ctx.save();
                ctx.translate(plane.x, plane.y);
                ctx.rotate(plane.vy * 0.05);
                
                if (speedBoostActive) {
                    const boostProgress = speedBoostStartedAt ? Math.min((time - speedBoostStartedAt) / SPEED_BOOST_DURATION, 1) : 0;
                    drawSpeedTrail(ctx, 0.5 + 0.3 * (1 - boostProgress));
                }
                
                // Body
                ctx.fillStyle = skin.body;
                ctx.fillRect(-35, -8, 70, 16);
                
                // Nose
                ctx.beginPath();
                ctx.moveTo(35, -8);
                ctx.lineTo(50, 0);
                ctx.lineTo(35, 8);
                ctx.fill();
                
                // Wings
                ctx.fillStyle = skin.wings;
                ctx.beginPath();
                ctx.moveTo(-10, -8);
                ctx.lineTo(-25, -30);
                ctx.lineTo(10, -8);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(-10, 8);
                ctx.lineTo(-25, 30);
                ctx.lineTo(10, 8);
                ctx.fill();
                
                // Tail fin
                ctx.fillStyle = skin.tail;
                ctx.beginPath();
                ctx.moveTo(-35, -5);
                ctx.lineTo(-45, -20);
                ctx.lineTo(-30, -5);
                ctx.fill();
                
                // Tail wings
                ctx.fillStyle = skin.wings;
                ctx.beginPath();
                ctx.moveTo(-32, 0);
                ctx.lineTo(-42, -10);
                ctx.lineTo(-28, 0);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(-32, 0);
                ctx.lineTo(-42, 10);
                ctx.lineTo(-28, 0);
                ctx.fill();
                
                // Cockpit
                ctx.fillStyle = skin.cockpit;
                ctx.beginPath();
                ctx.arc(20, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Cockpit shine
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(18, -2, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Windows
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.arc(-10 + i * 8, -4, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                
                if (shieldActive) {
                    ctx.save();
                    ctx.translate(plane.x, plane.y);
                    ctx.strokeStyle = 'rgba(78, 205, 196, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#4ecdc4';
                    ctx.shadowBlur = 15;
                    const pulse = 45 + Math.sin(time / 200) * 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, pulse, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Collision detection with clouds (adjusted for size)
                for (let i = clouds.length - 1; i >= 0; i--) {
                    const c = clouds[i];
                    const s = c.size || 1;
                    let dx = plane.x - (c.x + 25 * s);
                    let dy = plane.y - c.y;
                    let collisionRadius = 40 * s; // Bigger clouds = bigger collision area
                    if (Math.sqrt(dx*dx + dy*dy) < collisionRadius) {
                        applyCoinDamage({ amount: 2, color: '#ff6b6b', label: '-2' }, time);
                        clouds.splice(i, 1);
                    }
                }
                
                if (comboRoute) {
                    const comboPickupRadius = 28 + magnetBoost;
                    let broke = false;
                    for (let i = 0; i < comboRoute.nodes.length; i++) {
                        const node = comboRoute.nodes[i];
                        if (node.collected) continue;
                        const dx = plane.x - node.x;
                        const dy = plane.y - node.y;
                        if (Math.hypot(dx, dy) < comboPickupRadius) {
                            if (i === comboProgress) {
                                node.collected = true;
                                comboProgress++;
                                comboChainExpire = time + COMBO_CHAIN_TIMEOUT;
                                awardCoins(1, time, { coinTagText: '+1 route', skipWeatherBonus: true, sourceX: node.x, sourceY: node.y });
                                if (comboProgress >= comboRoute.nodes.length) {
                                    completeComboRoute(time);
                                } else {
                                    setComboStatusLine(`Combo ${comboProgress}/${comboRoute.nodes.length}`, 'alert');
                                }
                            } else {
                                failComboRoute('Wrong order', time);
                            }
                            broke = true;
                            break;
                        }
                    }
                    if (broke && !comboRoute) {
                        comboChainExpire = 0;
                    }
                }
                
                // Collision detection with stars (bonus points for harder difficulties)
                for (let i = stars.length - 1; i >= 0; i--) {
                    const star = stars[i];
                    let dx = plane.x - star.x;
                    let dy = plane.y - star.y;
                    const coinPickupRadius = SMALL_COIN_RADIUS + SMALL_COIN_PICKUP_PADDING + magnetBoost;
                    if (Math.sqrt(dx*dx + dy*dy) < coinPickupRadius) {
                        stars.splice(i, 1);
                        awardCoins(1, time, { sourceX: star.x, sourceY: star.y });
                    }
                }
                
                // Collision detection with big coins
                for (let i = bigCoins.length - 1; i >= 0; i--) {
                    const big = bigCoins[i];
                    let dx = plane.x - big.x;
                    let dy = plane.y - big.y;
                    const bigPickupRadius = BIG_COIN_BASE_RADIUS + BIG_COIN_PICKUP_PADDING + magnetBoost * 0.6;
                    if (Math.sqrt(dx*dx + dy*dy) < bigPickupRadius) {
                        bigCoins.splice(i, 1);
                        awardCoins(BIG_COIN_VALUE, time, { sourceX: big.x, sourceY: big.y });
                    }
                }
                
                // Collision detection with powerups
                for (let i = powerups.length - 1; i >= 0; i--) {
                    const item = powerups[i];
                    let dx = plane.x - item.x;
                    let dy = plane.y - item.y;
                    if (Math.sqrt(dx*dx + dy*dy) < 38 + magnetBoost * 0.5) {
                        powerups.splice(i, 1);
                        if (item.type === 'shield') {
                            activateShield(time);
                        }
                    }
                }
            }
            
            for (let i = burstEffects.length - 1; i >= 0; i--) {
                const effect = burstEffects[i];
                const progress = Math.min((time - effect.start) / DAMAGE_EFFECT_DURATION, 1);
                if (progress >= 1) {
                    burstEffects.splice(i, 1);
                    continue;
                }
                ctx.save();
                ctx.globalAlpha = 1 - progress;
                const isReward = effect.type === 'reward';
                ctx.strokeStyle = effect.color || (isReward ? '#ffd700' : '#ff6b6b');
                ctx.lineWidth = isReward ? 2.4 : 3;
                if (isReward) {
                    ctx.shadowColor = ctx.strokeStyle;
                    ctx.shadowBlur = 25 * (1 - progress);
                }
                ctx.beginPath();
                const baseRadius = isReward ? 25 : 35;
                const radiusGrowth = isReward ? 35 : 45;
                ctx.arc(effect.x, effect.y, baseRadius + progress * radiusGrowth, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = effect.textColor || (isReward ? '#ffeaa7' : '#ffffff');
                ctx.font = 'bold 26px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const baseYOffset = isReward ? 25 : 40;
                const offsetGrowth = isReward ? 20 : 30;
                ctx.fillText(effect.label || '-', effect.x, effect.y - baseYOffset - progress * offsetGrowth);
                ctx.restore();
            }
            
            drawWeatherOverlay(ctx, time);
            
            if (screenFlashAlpha > 0) {
                ctx.fillStyle = 'rgba(255, 99, 71,' + (screenFlashAlpha * 0.35) + ')';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                screenFlashAlpha = Math.max(0, screenFlashAlpha - 0.02);
            }
            
            requestAnimationFrame(loop);
        }
        
        // Start the loop
        requestAnimationFrame(loop);
    })();
    </script>
</body>
</html>
