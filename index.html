<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Drifter - Airplane Adventure</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Quicksand:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sky-top: #0f0c29;
            --sky-middle: #302b63;
            --sky-bottom: #24243e;
            --accent-gold: #ffd700;
            --accent-coral: #ff6b6b;
            --accent-teal: #4ecdc4;
            --cloud-white: rgba(255, 255, 255, 0.9);
        }

        body {
            font-family: 'Quicksand', sans-serif;
            overflow: hidden;
            background: linear-gradient(180deg, var(--sky-top) 0%, var(--sky-middle) 50%, var(--sky-bottom) 100%);
            min-height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        /* Animated star field background */
        .stars {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s ease-in-out infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        /* Canvas for game */
        #gameCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* UI Overlay */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .score-display {
            position: absolute;
            top: 30px;
            left: 30px;
            font-family: 'Fredoka One', cursive;
            font-size: 2rem;
            color: var(--accent-gold);
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .score-icon {
            width: 35px;
            height: 35px;
            background: linear-gradient(135deg, var(--accent-gold), #ffaa00);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .high-score {
            position: absolute;
            top: 30px;
            right: 30px;
            font-family: 'Fredoka One', cursive;
            font-size: 1.2rem;
            color: var(--accent-teal);
            text-shadow: 0 0 15px rgba(78, 205, 196, 0.5);
        }

        /* Start Screen */
        .start-screen, .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(15, 12, 41, 0.85);
            backdrop-filter: blur(10px);
            pointer-events: all;
            z-index: 100;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .start-screen.hidden, .game-over-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .game-title {
            font-family: 'Fredoka One', cursive;
            font-size: 4rem;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-coral), var(--accent-teal));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            margin-bottom: 10px;
            animation: titleFloat 3s ease-in-out infinite;
        }

        @keyframes titleFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .game-subtitle {
            font-family: 'Quicksand', sans-serif;
            font-size: 1.5rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 50px;
            letter-spacing: 3px;
        }

        .plane-preview {
            width: 120px;
            height: 120px;
            margin-bottom: 40px;
            animation: planePreviewFloat 2s ease-in-out infinite;
        }

        @keyframes planePreviewFloat {
            0%, 100% { transform: translateY(0) rotate(-5deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }

        .start-btn, .restart-btn {
            font-family: 'Fredoka One', cursive;
            font-size: 1.5rem;
            padding: 18px 50px;
            border: none;
            border-radius: 50px;
            background: linear-gradient(135deg, var(--accent-coral), #ff8e53);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(255, 107, 107, 0.4);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .start-btn:hover, .restart-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 40px rgba(255, 107, 107, 0.6);
        }

        .controls-hint {
            margin-top: 40px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 1rem;
            text-align: center;
        }

        .controls-hint span {
            display: inline-block;
            padding: 8px 15px;
            margin: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Game Over Screen */
        .final-score {
            font-family: 'Fredoka One', cursive;
            font-size: 5rem;
            color: var(--accent-gold);
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            margin: 20px 0;
        }

        .final-score-label {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        .new-high-score {
            font-family: 'Fredoka One', cursive;
            font-size: 1.5rem;
            color: var(--accent-teal);
            margin-bottom: 30px;
            animation: newHighScore 0.5s ease-in-out infinite alternate;
        }

        @keyframes newHighScore {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }

        /* Collectible burst effect */
        .collect-burst {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle, var(--accent-gold) 0%, transparent 70%);
            animation: burst 0.4s ease-out forwards;
            pointer-events: none;
        }

        @keyframes burst {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }

        /* Difficulty indicator */
        .difficulty-indicator {
            position: absolute;
            bottom: 30px;
            left: 30px;
            font-family: 'Quicksand', sans-serif;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.5);
        }

        .difficulty-bar {
            width: 150px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }

        .difficulty-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-teal), var(--accent-coral));
            border-radius: 3px;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div class="stars" id="stars"></div>
        <canvas id="gameCanvas"></canvas>
        
        <div class="ui-overlay">
            <div class="score-display">
                <div class="score-icon">‚òÖ</div>
                <span id="score">0</span>
            </div>
            <div class="high-score">Best: <span id="highScore">0</span></div>
            <div class="difficulty-indicator">
                <span>Speed Level</span>
                <div class="difficulty-bar">
                    <div class="difficulty-fill" id="difficultyFill" style="width: 10%"></div>
                </div>
            </div>
        </div>

        <!-- Start Screen -->
        <div class="start-screen" id="startScreen">
            <h1 class="game-title">Sky Drifter</h1>
            <p class="game-subtitle">Airplane Adventure</p>
            <svg class="plane-preview" viewBox="0 0 120 80">
                <defs>
                    <linearGradient id="bodyGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:#f0f0f0;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#e8e8e8;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#d0d0d0;stop-opacity:1" />
                    </linearGradient>
                    <linearGradient id="wingGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:#4ecdc4;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#26a69a;stop-opacity:1" />
                    </linearGradient>
                    <filter id="planeShadow" x="-20%" y="-20%" width="140%" height="140%">
                        <feDropShadow dx="2" dy="4" stdDeviation="3" flood-color="#000" flood-opacity="0.3"/>
                    </filter>
                </defs>
                <!-- Fuselage -->
                <ellipse cx="55" cy="40" rx="45" ry="12" fill="url(#bodyGradient)" filter="url(#planeShadow)"/>
                <!-- Nose cone -->
                <ellipse cx="100" cy="40" rx="12" ry="8" fill="#e0e0e0"/>
                <!-- Cockpit windows -->
                <ellipse cx="85" cy="38" rx="8" ry="5" fill="#2c3e50"/>
                <ellipse cx="85" cy="38" rx="6" ry="3" fill="#5dade2" opacity="0.7"/>
                <!-- Main wing -->
                <path d="M 35 40 L 15 20 L 55 35 L 55 45 L 15 60 L 35 40" fill="url(#wingGradient)" filter="url(#planeShadow)"/>
                <!-- Tail wing -->
                <path d="M 12 40 L 5 25 L 20 38 L 20 42 L 5 55 L 12 40" fill="url(#wingGradient)"/>
                <!-- Tail fin -->
                <path d="M 10 40 L 10 20 L 25 35 Z" fill="#ff6b6b"/>
                <!-- Engine -->
                <ellipse cx="45" cy="52" rx="8" ry="5" fill="#555"/>
                <!-- Window stripe -->
                <rect x="55" y="36" width="25" height="4" rx="2" fill="#2c3e50" opacity="0.5"/>
            </svg>
            <button class="start-btn" id="startBtn">Take Off!</button>
            <div class="controls-hint">
                <p>Use <span>‚Üë W</span> <span>‚Üì S</span> or <span>MOUSE</span> to fly</p>
                <p style="margin-top: 10px; opacity: 0.7">Collect stars ‚òÖ and avoid clouds ‚òÅ</p>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div class="game-over-screen hidden" id="gameOverScreen">
            <h1 class="game-title" style="font-size: 3rem;">Flight Ended</h1>
            <p class="final-score-label">Your Score</p>
            <div class="final-score" id="finalScore">0</div>
            <div class="new-high-score hidden" id="newHighScore">üéâ New High Score! üéâ</div>
            <button class="restart-btn" id="restartBtn">Fly Again</button>
            <div class="controls-hint">
                <p>Press <span>SPACE</span> or <span>ENTER</span> to restart</p>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // SKY DRIFTER - Paper Airplane Game
        // ============================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameState = 'start'; // 'start', 'playing', 'gameover'
        let score = 0;
        let highScore = parseInt(localStorage.getItem('skyDrifterHighScore')) || 0;
        let gameSpeed = 3;
        let difficultyLevel = 1;

        // Update high score display
        document.getElementById('highScore').textContent = highScore;

        // Canvas sizing
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Generate stars background
        function generateStars() {
            const starsContainer = document.getElementById('stars');
            starsContainer.innerHTML = '';
            for (let i = 0; i < 100; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = (Math.random() * 3 + 1) + 'px';
                star.style.height = star.style.width;
                star.style.animationDelay = Math.random() * 2 + 's';
                starsContainer.appendChild(star);
            }
        }
        generateStars();

        // ============================================
        // PLANE CLASS
        // ============================================
        class Plane {
            constructor() {
                this.width = 80;
                this.height = 50;
                this.x = canvas.width * 0.15;
                this.y = canvas.height / 2;
                this.velocity = 0;
                this.gravity = 0.25;
                this.lift = -0.5;
                this.maxVelocity = 8;
                this.rotation = 0;
                this.targetY = this.y;
                this.trail = [];
                this.maxTrailLength = 15;
            }

            update() {
                // Smooth movement towards target (mouse) or keyboard
                if (keys.up || keys.w) {
                    this.velocity += this.lift;
                }
                if (keys.down || keys.s) {
                    this.velocity += 0.5;
                }

                // Mouse following
                if (mouseY !== null && !keys.up && !keys.down && !keys.w && !keys.s) {
                    const diff = mouseY - this.y;
                    this.velocity += diff * 0.02;
                }

                // Apply subtle gravity
                this.velocity += this.gravity * 0.3;

                // Clamp velocity
                this.velocity = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.velocity));

                // Apply velocity with damping
                this.y += this.velocity;
                this.velocity *= 0.95;

                // Boundary check
                if (this.y < this.height / 2) {
                    this.y = this.height / 2;
                    this.velocity = 0;
                }
                if (this.y > canvas.height - this.height / 2) {
                    this.y = canvas.height - this.height / 2;
                    this.velocity = 0;
                }

                // Rotation based on velocity
                this.rotation = this.velocity * 2;
                this.rotation = Math.max(-30, Math.min(30, this.rotation));

                // Trail
                this.trail.unshift({ x: this.x - 20, y: this.y, alpha: 1 });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.pop();
                }
            }

            draw() {
                // Draw engine exhaust trail
                this.trail.forEach((point, index) => {
                    const alpha = 1 - (index / this.maxTrailLength);
                    const size = (1 - index / this.maxTrailLength) * 6;
                    ctx.beginPath();
                    ctx.arc(point.x - index * 4, point.y + 5, size, 0, Math.PI * 2);
                    // Exhaust colors: white to gray
                    const gray = Math.floor(200 + index * 3);
                    ctx.fillStyle = `rgba(${gray}, ${gray}, ${gray}, ${alpha * 0.6})`;
                    ctx.fill();
                });

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation * Math.PI / 180);

                const w = this.width;
                const h = this.height;

                // Shadow under the plane
                ctx.beginPath();
                ctx.ellipse(5, 12, w * 0.4, 6, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.fill();

                // Main fuselage
                const bodyGradient = ctx.createLinearGradient(0, -h/2, 0, h/2);
                bodyGradient.addColorStop(0, '#f5f5f5');
                bodyGradient.addColorStop(0.3, '#ffffff');
                bodyGradient.addColorStop(0.7, '#e0e0e0');
                bodyGradient.addColorStop(1, '#c0c0c0');
                
                ctx.beginPath();
                ctx.ellipse(0, 0, w * 0.5, h * 0.28, 0, 0, Math.PI * 2);
                ctx.fillStyle = bodyGradient;
                ctx.fill();
                ctx.strokeStyle = '#b0b0b0';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Nose cone
                ctx.beginPath();
                ctx.ellipse(w * 0.4, 0, w * 0.15, h * 0.2, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#e8e8e8';
                ctx.fill();
                ctx.stroke();

                // Main wings
                const wingGradient = ctx.createLinearGradient(0, -h, 0, h);
                wingGradient.addColorStop(0, '#4ecdc4');
                wingGradient.addColorStop(0.5, '#45b7aa');
                wingGradient.addColorStop(1, '#26a69a');

                // Top wing
                ctx.beginPath();
                ctx.moveTo(-w * 0.1, -h * 0.15);
                ctx.lineTo(-w * 0.35, -h * 0.7);
                ctx.lineTo(w * 0.15, -h * 0.15);
                ctx.closePath();
                ctx.fillStyle = wingGradient;
                ctx.fill();
                ctx.strokeStyle = '#1e8a7e';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Bottom wing
                ctx.beginPath();
                ctx.moveTo(-w * 0.1, h * 0.15);
                ctx.lineTo(-w * 0.35, h * 0.7);
                ctx.lineTo(w * 0.15, h * 0.15);
                ctx.closePath();
                ctx.fillStyle = wingGradient;
                ctx.fill();
                ctx.stroke();

                // Tail fin (vertical stabilizer)
                ctx.beginPath();
                ctx.moveTo(-w * 0.4, -h * 0.1);
                ctx.lineTo(-w * 0.5, -h * 0.5);
                ctx.lineTo(-w * 0.3, -h * 0.1);
                ctx.closePath();
                ctx.fillStyle = '#ff6b6b';
                ctx.fill();
                ctx.strokeStyle = '#e55555';
                ctx.stroke();

                // Tail wings (horizontal stabilizers)
                ctx.beginPath();
                ctx.moveTo(-w * 0.4, 0);
                ctx.lineTo(-w * 0.55, -h * 0.25);
                ctx.lineTo(-w * 0.3, 0);
                ctx.closePath();
                ctx.fillStyle = '#4ecdc4';
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(-w * 0.4, 0);
                ctx.lineTo(-w * 0.55, h * 0.25);
                ctx.lineTo(-w * 0.3, 0);
                ctx.closePath();
                ctx.fillStyle = '#4ecdc4';
                ctx.fill();

                // Cockpit window
                ctx.beginPath();
                ctx.ellipse(w * 0.25, -h * 0.05, w * 0.12, h * 0.12, -0.2, 0, Math.PI * 2);
                ctx.fillStyle = '#2c3e50';
                ctx.fill();
                
                // Cockpit reflection
                ctx.beginPath();
                ctx.ellipse(w * 0.27, -h * 0.08, w * 0.08, h * 0.06, -0.2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(93, 173, 226, 0.6)';
                ctx.fill();

                // Window stripe on fuselage
                ctx.beginPath();
                ctx.moveTo(-w * 0.2, -h * 0.08);
                ctx.lineTo(w * 0.1, -h * 0.08);
                ctx.lineTo(w * 0.1, h * 0.02);
                ctx.lineTo(-w * 0.2, h * 0.02);
                ctx.closePath();
                ctx.fillStyle = 'rgba(44, 62, 80, 0.4)';
                ctx.fill();

                // Engine under wing
                ctx.beginPath();
                ctx.ellipse(-w * 0.05, h * 0.35, w * 0.08, h * 0.12, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#555';
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.stroke();

                // Engine intake
                ctx.beginPath();
                ctx.ellipse(w * 0.02, h * 0.35, w * 0.04, h * 0.08, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#222';
                ctx.fill();

                // Highlight on fuselage
                ctx.beginPath();
                ctx.ellipse(w * 0.1, -h * 0.18, w * 0.25, h * 0.05, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fill();

                ctx.restore();
            }

            getBounds() {
                return {
                    x: this.x - this.width / 3,
                    y: this.y - this.height / 3,
                    width: this.width * 0.6,
                    height: this.height * 0.6
                };
            }
        }

        // ============================================
        // CLOUD (OBSTACLE) CLASS
        // ============================================
        class Cloud {
            constructor() {
                this.width = 80 + Math.random() * 60;
                this.height = 40 + Math.random() * 30;
                this.x = canvas.width + this.width;
                this.y = Math.random() * (canvas.height - this.height - 100) + 50;
                this.baseSpeed = 1 + Math.random() * 2;
                this.opacity = 0.7 + Math.random() * 0.3;
                this.puffs = [];
                
                // Generate cloud puffs
                const numPuffs = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < numPuffs; i++) {
                    this.puffs.push({
                        x: (i / numPuffs) * this.width * 0.8,
                        y: Math.random() * this.height * 0.3,
                        radius: 15 + Math.random() * 20
                    });
                }
            }

            update() {
                this.x -= (this.baseSpeed + gameSpeed);
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Draw cloud puffs
                this.puffs.forEach(puff => {
                    const gradient = ctx.createRadialGradient(
                        puff.x, puff.y, 0,
                        puff.x, puff.y, puff.radius
                    );
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${this.opacity})`);
                    gradient.addColorStop(0.5, `rgba(240, 240, 255, ${this.opacity * 0.8})`);
                    gradient.addColorStop(1, `rgba(220, 220, 240, 0)`);
                    
                    ctx.beginPath();
                    ctx.arc(puff.x, puff.y, puff.radius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                });

                // Cloud shadow
                ctx.beginPath();
                ctx.ellipse(this.width / 2, this.height + 5, this.width / 2.5, 8, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fill();

                ctx.restore();
            }

            getBounds() {
                return {
                    x: this.x + 10,
                    y: this.y - 10,
                    width: this.width - 20,
                    height: this.height + 10
                };
            }

            isOffScreen() {
                return this.x + this.width < 0;
            }
        }

        // ============================================
        // STAR (COLLECTIBLE) CLASS
        // ============================================
        class Star {
            constructor() {
                this.radius = 15;
                this.x = canvas.width + this.radius;
                this.y = Math.random() * (canvas.height - 100) + 50;
                this.baseSpeed = 2;
                this.rotation = 0;
                this.rotationSpeed = 3 + Math.random() * 2;
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.collected = false;
            }

            update() {
                this.x -= (this.baseSpeed + gameSpeed);
                this.rotation += this.rotationSpeed;
                this.pulsePhase += 0.1;
            }

            draw() {
                if (this.collected) return;

                const pulse = 1 + Math.sin(this.pulsePhase) * 0.15;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation * Math.PI / 180);
                ctx.scale(pulse, pulse);

                // Glow effect
                const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 2);
                glowGradient.addColorStop(0, 'rgba(255, 215, 0, 0.6)');
                glowGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.2)');
                glowGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 2, 0, Math.PI * 2);
                ctx.fillStyle = glowGradient;
                ctx.fill();

                // Star shape
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                    const x = Math.cos(angle) * this.radius;
                    const y = Math.sin(angle) * this.radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                
                const starGradient = ctx.createLinearGradient(-this.radius, -this.radius, this.radius, this.radius);
                starGradient.addColorStop(0, '#ffd700');
                starGradient.addColorStop(0.5, '#ffec8b');
                starGradient.addColorStop(1, '#ffa500');
                ctx.fillStyle = starGradient;
                ctx.fill();
                ctx.strokeStyle = '#ff8c00';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Shine
                ctx.beginPath();
                ctx.arc(-3, -3, 4, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fill();

                ctx.restore();
            }

            getBounds() {
                return {
                    x: this.x - this.radius,
                    y: this.y - this.radius,
                    width: this.radius * 2,
                    height: this.radius * 2
                };
            }

            isOffScreen() {
                return this.x + this.radius < 0;
            }
        }

        // ============================================
        // PARTICLE SYSTEM
        // ============================================
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
                this.life = 1;
                this.decay = 0.02 + Math.random() * 0.02;
                this.color = color;
                this.size = 3 + Math.random() * 5;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                this.vx *= 0.98;
                this.vy *= 0.98;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
                ctx.fillStyle = this.color.replace('1)', `${this.life})`);
                ctx.fill();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // ============================================
        // GAME OBJECTS
        // ============================================
        let plane;
        let clouds = [];
        let stars = [];
        let particles = [];
        let lastCloudSpawn = 0;
        let lastStarSpawn = 0;
        let cloudSpawnInterval = 2000;
        let starSpawnInterval = 1500;

        // Input handling
        let keys = { up: false, down: false, w: false, s: false };
        let mouseY = null;

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') keys.up = true;
            if (e.key === 'ArrowDown') keys.down = true;
            if (e.key === 'w' || e.key === 'W') keys.w = true;
            if (e.key === 's' || e.key === 'S') keys.s = true;
            
            if ((e.key === ' ' || e.key === 'Enter') && gameState === 'gameover') {
                restartGame();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowUp') keys.up = false;
            if (e.key === 'ArrowDown') keys.down = false;
            if (e.key === 'w' || e.key === 'W') keys.w = false;
            if (e.key === 's' || e.key === 'S') keys.s = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            mouseY = e.clientY;
        });

        canvas.addEventListener('mouseleave', () => {
            mouseY = null;
        });

        // UI Buttons
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', restartGame);

        // ============================================
        // GAME FUNCTIONS
        // ============================================
        function startGame() {
            gameState = 'playing';
            score = 0;
            gameSpeed = 3;
            difficultyLevel = 1;
            plane = new Plane();
            clouds = [];
            stars = [];
            particles = [];
            document.getElementById('score').textContent = '0';
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            lastCloudSpawn = Date.now();
            lastStarSpawn = Date.now();
        }

        function restartGame() {
            startGame();
        }

        function gameOver() {
            gameState = 'gameover';
            document.getElementById('finalScore').textContent = score;
            
            // Check for high score
            const newHighScoreEl = document.getElementById('newHighScore');
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('skyDrifterHighScore', highScore);
                document.getElementById('highScore').textContent = highScore;
                newHighScoreEl.classList.remove('hidden');
            } else {
                newHighScoreEl.classList.add('hidden');
            }
            
            document.getElementById('gameOverScreen').classList.remove('hidden');

            // Explosion particles
            for (let i = 0; i < 30; i++) {
                particles.push(new Particle(plane.x, plane.y, 'rgba(255, 107, 107, 1)'));
            }
        }

        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function spawnCloud() {
            clouds.push(new Cloud());
        }

        function spawnStar() {
            // Make sure star doesn't spawn inside a cloud
            const star = new Star();
            let valid = true;
            for (const cloud of clouds) {
                if (checkCollision(star.getBounds(), cloud.getBounds())) {
                    valid = false;
                    break;
                }
            }
            if (valid) {
                stars.push(star);
            }
        }

        function collectStar(star) {
            star.collected = true;
            score += 10;
            document.getElementById('score').textContent = score;

            // Spawn collection particles
            for (let i = 0; i < 15; i++) {
                particles.push(new Particle(star.x, star.y, 'rgba(255, 215, 0, 1)'));
            }

            // Increase difficulty every 50 points
            if (score % 50 === 0) {
                gameSpeed = Math.min(gameSpeed + 0.3, 10);
                difficultyLevel = Math.min(difficultyLevel + 1, 10);
                cloudSpawnInterval = Math.max(cloudSpawnInterval - 100, 800);
                document.getElementById('difficultyFill').style.width = (difficultyLevel * 10) + '%';
            }
        }

        // ============================================
        // BACKGROUND RENDERING
        // ============================================
        function drawBackground() {
            // Moving gradient background based on score
            const hueShift = (score * 0.5) % 30;
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, `hsl(${250 + hueShift}, 40%, 15%)`);
            gradient.addColorStop(0.5, `hsl(${260 + hueShift}, 35%, 25%)`);
            gradient.addColorStop(1, `hsl(${245 + hueShift}, 30%, 20%)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Distant mountains silhouette
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            let mountainX = 0;
            while (mountainX < canvas.width + 100) {
                const height = 100 + Math.sin(mountainX * 0.005 + Date.now() * 0.0001) * 50;
                ctx.lineTo(mountainX, canvas.height - height);
                mountainX += 50;
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fillStyle = 'rgba(20, 20, 40, 0.5)';
            ctx.fill();
        }

        // ============================================
        // MAIN GAME LOOP
        // ============================================
        let lastTime = 0;

        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw background
            drawBackground();

            if (gameState === 'playing') {
                // Spawn obstacles and collectibles
                if (Date.now() - lastCloudSpawn > cloudSpawnInterval) {
                    spawnCloud();
                    lastCloudSpawn = Date.now();
                }

                if (Date.now() - lastStarSpawn > starSpawnInterval) {
                    spawnStar();
                    lastStarSpawn = Date.now();
                }

                // Update and draw clouds
                clouds = clouds.filter(cloud => !cloud.isOffScreen());
                clouds.forEach(cloud => {
                    cloud.update();
                    cloud.draw();
                });

                // Update and draw stars
                stars = stars.filter(star => !star.isOffScreen() && !star.collected);
                stars.forEach(star => {
                    star.update();
                    star.draw();
                });

                // Update and draw plane
                plane.update();
                plane.draw();

                // Check collisions with clouds
                const planeBounds = plane.getBounds();
                for (const cloud of clouds) {
                    if (checkCollision(planeBounds, cloud.getBounds())) {
                        gameOver();
                        break;
                    }
                }

                // Check collisions with stars
                for (const star of stars) {
                    if (!star.collected && checkCollision(planeBounds, star.getBounds())) {
                        collectStar(star);
                    }
                }
            }

            // Update and draw particles (always, even during game over)
            particles = particles.filter(p => !p.isDead());
            particles.forEach(p => {
                p.update();
                p.draw();
            });

            requestAnimationFrame(gameLoop);
        }

        // Start the game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
